# verify_files Variable Expansion Sample Configuration
#
# This sample demonstrates how to use environment variable expansion in verify_files fields.
# The verify_files feature allows you to dynamically construct file verification paths using
# environment variables, providing flexibility for different deployment environments.
#
# Features demonstrated:
# 1. Global-level verify_files expansion
# 2. Group-level verify_files expansion
# 3. Multiple environment variables in a single path
# 4. Environment-specific configurations (dev/staging/prod)
# 5. Allowlist inheritance
#
# Prerequisites:
# Before running this configuration, set the following environment variables:
#   export DEPLOY_ENV=production        # or: development, staging
#   export APP_ROOT=/opt/myapp
#   export CONFIG_ROOT=/etc/myapp/config
#   export DATA_ROOT=/var/lib/myapp

version = "1.0"

[global]
timeout = 300
log_level = "info"
workdir = "/tmp"

# Environment variable allowlist for global scope
# These variables can be used in global verify_files
env_allowlist = ["DEPLOY_ENV", "CONFIG_ROOT", "APP_ROOT", "DATA_ROOT"]

# Global verify_files with environment variable expansion
# These files will be verified before any group execution
verify_files = [
    "${CONFIG_ROOT}/${DEPLOY_ENV}/global.yml",
    "${CONFIG_ROOT}/${DEPLOY_ENV}/secrets.enc",
    "${APP_ROOT}/LICENSE",
    "${APP_ROOT}/VERSION",
]

# Example 1: Web Server Deployment Group
# Demonstrates group-level verify_files with explicit allowlist
[[groups]]
name = "web_servers"
description = "Deploy and configure web servers"

# Group-level allowlist (overrides global allowlist for this group)
env_allowlist = ["DEPLOY_ENV", "APP_ROOT"]

# Group verify_files - these files are verified before executing commands in this group
verify_files = [
    "${APP_ROOT}/web/nginx.conf",
    "${APP_ROOT}/web/ssl/cert.pem",
    "${APP_ROOT}/web/ssl/key.pem",
    "${APP_ROOT}/web/static/index.html",
]

[[groups.commands]]
name = "deploy_web_config"
description = "Deploy web server configuration"
cmd = "/bin/cp"
args = [
    "${APP_ROOT}/web/nginx.conf",
    "/etc/nginx/sites-available/myapp.conf",
]
env = ["APP_ROOT=/opt/myapp"]

[[groups.commands]]
name = "reload_nginx"
description = "Reload nginx configuration"
cmd = "/usr/sbin/nginx"
args = ["-s", "reload"]

# Example 2: Database Management Group
# Demonstrates allowlist inheritance (uses global allowlist)
[[groups]]
name = "database"
description = "Database schema and migration management"

# No env_allowlist specified - inherits from global allowlist

# Group verify_files using inherited global allowlist
verify_files = [
    "${APP_ROOT}/db/schema.sql",
    "${APP_ROOT}/db/migrations/${DEPLOY_ENV}/001_initial.sql",
    "${DATA_ROOT}/db/backup/.gitkeep",
]

[[groups.commands]]
name = "run_migrations"
description = "Run database migrations"
cmd = "${APP_ROOT}/scripts/migrate.sh"
args = ["${DEPLOY_ENV}"]
env = [
    "APP_ROOT=/opt/myapp",
    "DEPLOY_ENV=production",
]
timeout = 600

[[groups.commands]]
name = "verify_schema"
description = "Verify database schema"
cmd = "${APP_ROOT}/scripts/verify_schema.sh"
args = ["${DATA_ROOT}/db/production.db"]
env = [
    "APP_ROOT=/opt/myapp",
    "DATA_ROOT=/var/lib/myapp",
]

# Example 3: Application Deployment Group
# Demonstrates complex path construction with multiple variables
[[groups]]
name = "application"
description = "Deploy application binaries and configuration"

env_allowlist = ["APP_ROOT", "DEPLOY_ENV", "CONFIG_ROOT"]

verify_files = [
    "${APP_ROOT}/bin/server",
    "${APP_ROOT}/bin/worker",
    "${CONFIG_ROOT}/${DEPLOY_ENV}/app.yml",
    "${CONFIG_ROOT}/${DEPLOY_ENV}/database.yml",
    "${CONFIG_ROOT}/${DEPLOY_ENV}/redis.yml",
]

[[groups.commands]]
name = "deploy_app_config"
description = "Deploy application configuration files"
cmd = "/bin/cp"
args = [
    "${CONFIG_ROOT}/${DEPLOY_ENV}/app.yml",
    "/etc/myapp/app.yml",
]
env = [
    "CONFIG_ROOT=/etc/myapp/config",
    "DEPLOY_ENV=production",
]

[[groups.commands]]
name = "start_server"
description = "Start application server"
cmd = "${APP_ROOT}/bin/server"
args = [
    "--config", "/etc/myapp/app.yml",
    "--env", "${DEPLOY_ENV}",
]
env = [
    "APP_ROOT=/opt/myapp",
    "DEPLOY_ENV=production",
]
timeout = 60

# Example 4: Monitoring and Logging Group
# Demonstrates environment-specific file verification
[[groups]]
name = "monitoring"
description = "Setup monitoring and logging"

env_allowlist = ["APP_ROOT", "DATA_ROOT", "DEPLOY_ENV"]

# Different log directories and configurations based on environment
verify_files = [
    "${DATA_ROOT}/logs/${DEPLOY_ENV}/.gitkeep",
    "${APP_ROOT}/monitoring/prometheus.yml",
    "${APP_ROOT}/monitoring/grafana-dashboard.json",
]

[[groups.commands]]
name = "configure_prometheus"
description = "Configure Prometheus monitoring"
cmd = "/bin/cp"
args = [
    "${APP_ROOT}/monitoring/prometheus.yml",
    "/etc/prometheus/prometheus.yml",
]
env = ["APP_ROOT=/opt/myapp"]

[[groups.commands]]
name = "setup_log_rotation"
description = "Setup log rotation for application logs"
cmd = "/usr/sbin/logrotate"
args = [
    "-f",
    "${APP_ROOT}/monitoring/logrotate.conf",
]
env = ["APP_ROOT=/opt/myapp"]

# Example 5: Backup and Restore Group
# Demonstrates date-based path construction (though variables are static in verify_files)
[[groups]]
name = "backup"
description = "Backup and restore operations"

env_allowlist = ["DATA_ROOT", "APP_ROOT"]

verify_files = [
    "${DATA_ROOT}/backups/.gitkeep",
    "${APP_ROOT}/scripts/backup.sh",
    "${APP_ROOT}/scripts/restore.sh",
]

[[groups.commands]]
name = "create_backup"
description = "Create database and file backup"
cmd = "${APP_ROOT}/scripts/backup.sh"
args = [
    "--db", "${DATA_ROOT}/db/production.db",
    "--output", "${DATA_ROOT}/backups/backup-${__RUNNER_DATETIME}.tar.gz",
]
env = [
    "APP_ROOT=/opt/myapp",
    "DATA_ROOT=/var/lib/myapp",
]
timeout = 1800

[[groups.commands]]
name = "cleanup_old_backups"
description = "Remove backups older than 30 days"
cmd = "/usr/bin/find"
args = [
    "${DATA_ROOT}/backups",
    "-name", "backup-*.tar.gz",
    "-mtime", "+30",
    "-delete",
]
env = ["DATA_ROOT=/var/lib/myapp"]

# Notes:
#
# 1. Variable Expansion Timing:
#    - verify_files variables are expanded during configuration loading
#    - All variables must be set in the environment before running the runner
#
# 2. Allowlist Behavior:
#    - Global verify_files uses global env_allowlist
#    - Group verify_files uses group env_allowlist (if specified) or inherits from global
#    - Empty group env_allowlist [] blocks all system variables (explicit reject mode)
#
# 3. Security:
#    - All variables used in verify_files must be in the allowlist
#    - Expanded paths must be absolute paths
#    - System environment variables only (Command.Env variables cannot be used)
#
# 4. Error Handling:
#    - Undefined variables cause configuration load errors
#    - Allowlist violations cause configuration load errors
#    - Invalid paths (relative, traversal) cause verification errors
#
# 5. Example Environment Setup:
#
#    Development:
#      export DEPLOY_ENV=development
#      export APP_ROOT=/home/developer/myapp
#      export CONFIG_ROOT=/home/developer/myapp/config
#      export DATA_ROOT=/home/developer/myapp/data
#
#    Staging:
#      export DEPLOY_ENV=staging
#      export APP_ROOT=/opt/myapp
#      export CONFIG_ROOT=/etc/myapp/config
#      export DATA_ROOT=/var/lib/myapp-staging
#
#    Production:
#      export DEPLOY_ENV=production
#      export APP_ROOT=/opt/myapp
#      export CONFIG_ROOT=/etc/myapp/config
#      export DATA_ROOT=/var/lib/myapp
#
# 6. Testing this Configuration:
#
#    # Set environment variables
#    export DEPLOY_ENV=production
#    export APP_ROOT=/opt/myapp
#    export CONFIG_ROOT=/etc/myapp/config
#    export DATA_ROOT=/var/lib/myapp
#
#    # Create required directory structure (for testing)
#    mkdir -p /opt/myapp/{bin,web/{ssl,static},db/migrations/production,scripts,monitoring}
#    mkdir -p /etc/myapp/config/production
#    mkdir -p /var/lib/myapp/{logs/production,backups,db}
#
#    # Create placeholder files
#    touch /etc/myapp/config/production/{global.yml,secrets.enc,app.yml,database.yml,redis.yml}
#    touch /opt/myapp/{LICENSE,VERSION}
#    touch /opt/myapp/web/nginx.conf
#    touch /opt/myapp/web/ssl/{cert.pem,key.pem}
#    touch /opt/myapp/web/static/index.html
#    touch /opt/myapp/db/schema.sql
#    touch /opt/myapp/db/migrations/production/001_initial.sql
#    touch /var/lib/myapp/db/backup/.gitkeep
#    touch /opt/myapp/bin/{server,worker}
#    touch /var/lib/myapp/logs/production/.gitkeep
#    touch /opt/myapp/monitoring/{prometheus.yml,grafana-dashboard.json}
#    touch /var/lib/myapp/backups/.gitkeep
#    touch /opt/myapp/scripts/{backup.sh,restore.sh,migrate.sh,verify_schema.sh}
#
#    # Record hashes (assuming hash directory is /tmp/hashes)
#    ./build/record -d /tmp/hashes verify_files_expansion.toml
#
#    # Run the configuration
#    ./build/runner -d /tmp/hashes verify_files_expansion.toml
