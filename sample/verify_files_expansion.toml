# verify_files Variable Expansion Sample Configuration
#
# This sample demonstrates how to use internal variable expansion in verify_files fields.
# The verify_files feature allows you to dynamically construct file verification paths using
# internal variables (from_env and vars), providing flexibility for different deployment environments.
#
# Features demonstrated:
# 1. Global-level verify_files expansion
# 2. Group-level verify_files expansion
# 3. Multiple internal variables in a single path
# 4. Environment-specific configurations (dev/staging/prod)
# 5. Allowlist inheritance
#
# Prerequisites:
# Before running this configuration, set the following environment variables:
#   export DEPLOY_ENV=production        # or: development, staging
#   export APP_ROOT=/opt/myapp
#   export CONFIG_ROOT=/etc/myapp/config
#   export DATA_ROOT=/var/lib/myapp

version = "1.0"

[global]
timeout = 300
log_level = "info"
workdir = "/tmp"

# Environment variable allowlist for global scope
# These variables can be imported via from_env
env_allowlist = ["DEPLOY_ENV", "CONFIG_ROOT", "APP_ROOT", "DATA_ROOT"]

# Import system environment variables as internal variables
from_env = [
    "deploy_env=DEPLOY_ENV",
    "config_root=CONFIG_ROOT",
    "app_root=APP_ROOT",
    "data_root=DATA_ROOT"
]

# Global verify_files with internal variable expansion
# These files will be verified before any group execution
verify_files = [
    "%{config_root}/%{deploy_env}/global.yml",
    "%{config_root}/%{deploy_env}/secrets.enc",
    "%{app_root}/LICENSE",
    "%{app_root}/VERSION",
]

# Example 1: Web Server Deployment Group
# Demonstrates group-level verify_files with explicit allowlist
[[groups]]
name = "web_servers"
description = "Deploy and configure web servers"

# Group-level allowlist (overrides global allowlist for this group)
env_allowlist = ["DEPLOY_ENV", "APP_ROOT"]

# Group-level from_env (overrides global from_env)
from_env = [
    "deploy_env=DEPLOY_ENV",
    "app_root=APP_ROOT"
]

# Group verify_files - these files are verified before executing commands in this group
verify_files = [
    "%{app_root}/web/nginx.conf",
    "%{app_root}/web/ssl/cert.pem",
    "%{app_root}/web/ssl/key.pem",
    "%{app_root}/web/static/index.html",
]

[[groups.commands]]
name = "deploy_web_config"
description = "Deploy web server configuration"
cmd = "/bin/cp"
args = [
    "%{app_root}/web/nginx.conf",
    "/etc/nginx/sites-available/myapp.conf",
]
vars = ["app_root=/opt/myapp"]

[[groups.commands]]
name = "reload_nginx"
description = "Reload nginx configuration"
cmd = "/usr/sbin/nginx"
args = ["-s", "reload"]

# Example 2: Database Management Group
# Demonstrates allowlist inheritance (uses global allowlist)
[[groups]]
name = "database"
description = "Database schema and migration management"

# No env_allowlist specified - inherits from global allowlist
# No from_env specified - inherits from global from_env

# Group verify_files using inherited global from_env
verify_files = [
    "%{app_root}/db/schema.sql",
    "%{app_root}/db/migrations/%{deploy_env}/001_initial.sql",
    "%{data_root}/db/backup/.gitkeep",
]

[[groups.commands]]
name = "run_migrations"
description = "Run database migrations"
cmd = "%{app_root}/scripts/migrate.sh"
args = ["%{env_type}"]
vars = [
    "app_root=/opt/myapp",
    "env_type=production"
]
timeout = 600

[[groups.commands]]
name = "verify_schema"
description = "Verify database schema"
cmd = "%{app_root}/scripts/verify_schema.sh"
args = ["%{data_root}/production.db"]
from_env = [
    "app_root=/opt/myapp",
    "data_root=/var/lib/myapp/db"
]

# Example 3: Application Deployment Group
# Demonstrates complex path construction with multiple variables
[[groups]]
name = "application"
description = "Deploy application binaries and configuration"

env_allowlist = ["APP_ROOT", "DEPLOY_ENV", "CONFIG_ROOT"]
from_env = [
    "app_root=APP_ROOT",
    "deploy_env=DEPLOY_ENV",
    "config_root=CONFIG_ROOT"
]

verify_files = [
    "%{app_root}/bin/server",
    "%{app_root}/bin/worker",
    "%{config_root}/%{deploy_env}/app.yml",
    "%{config_root}/%{deploy_env}/database.yml",
    "%{config_root}/%{deploy_env}/redis.yml",
]

[[groups.commands]]
name = "deploy_app_config"
description = "Deploy application configuration files"
cmd = "/bin/cp"
args = [
    "%{config_root}/%{env_type}/app.yml",
    "/etc/myapp/app.yml",
]
vars = [
    "config_root=/etc/myapp/config",
    "env_type=production"
]

[[groups.commands]]
name = "start_server"
description = "Start application server"
cmd = "%{app_root}/bin/server"
args = [
    "--config", "/etc/myapp/app.yml",
    "--env", "%{env_type}",
]
vars = [
    "app_root=/opt/myapp",
    "env_type=production"
]
timeout = 60

# Example 4: Monitoring and Logging Group
# Demonstrates environment-specific file verification
[[groups]]
name = "monitoring"
description = "Setup monitoring and logging"

env_allowlist = ["APP_ROOT", "DATA_ROOT", "DEPLOY_ENV"]
from_env = [
    "app_root=APP_ROOT",
    "data_root=DATA_ROOT",
    "deploy_env=DEPLOY_ENV"
]

# Different log directories and configurations based on environment
verify_files = [
    "%{data_root}/logs/%{deploy_env}/.gitkeep",
    "%{app_root}/monitoring/prometheus.yml",
    "%{app_root}/monitoring/grafana-dashboard.json",
]

[[groups.commands]]
name = "configure_prometheus"
description = "Configure Prometheus monitoring"
cmd = "/bin/cp"
args = [
    "%{app_root}/monitoring/prometheus.yml",
    "/etc/prometheus/prometheus.yml",
]
vars = ["app_root=/opt/myapp"]

[[groups.commands]]
name = "setup_log_rotation"
description = "Setup log rotation for application logs"
cmd = "/usr/sbin/logrotate"
args = [
    "-f",
    "%{app_root}/monitoring/logrotate.conf",
]
vars = ["app_root=/opt/myapp"]

# Example 5: Backup and Restore Group
# Demonstrates date-based path construction (though variables are static in verify_files)
[[groups]]
name = "backup"
description = "Backup and restore operations"

env_allowlist = ["DATA_ROOT", "APP_ROOT"]
from_env = [
    "data_root=DATA_ROOT",
    "app_root=APP_ROOT"
]

verify_files = [
    "%{data_root}/backups/.gitkeep",
    "%{app_root}/scripts/backup.sh",
    "%{app_root}/scripts/restore.sh",
]

[[groups.commands]]
name = "create_backup"
description = "Create database and file backup"
cmd = "%{app_root}/scripts/backup.sh"
args = [
    "--db", "%{data_root}/db/production.db",
    "--output", "%{data_root}/backups/backup-%{__runner_datetime}.tar.gz",
]
from_env = [
    "app_root=APP_ROOT",
    "data_root=DATA_ROOT"
]
timeout = 1800

[[groups.commands]]
name = "cleanup_old_backups"
description = "Remove backups older than 30 days"
cmd = "/usr/bin/find"
args = [
    "%{data_root}/backups",
    "-name", "backup-*.tar.gz",
    "-mtime", "+30",
    "-delete",
]
from_env = ["data_root=DATA_ROOT"]

# Notes:
#
# 1. Variable Expansion Timing:
#    - verify_files variables are expanded during configuration loading
#    - All variables must be set in the environment before running the runner
#
# 2. Allowlist Behavior:
#    - Global verify_files uses global env_allowlist
#    - Group verify_files uses group env_allowlist (if specified) or inherits from global
#    - Empty group env_allowlist [] blocks all system variables (explicit reject mode)
#
# 3. Security:
#    - All variables used in verify_files must be in the allowlist
#    - Expanded paths must be absolute paths
#    - System environment variables are imported via from_env
#
# 4. Error Handling:
#    - Undefined variables cause configuration load errors
#    - Allowlist violations cause configuration load errors
#    - Invalid paths (relative, traversal) cause verification errors
#
# 5. Example Environment Setup:
#
#    Development:
#      export DEPLOY_ENV=development
#      export APP_ROOT=/home/developer/myapp
#      export CONFIG_ROOT=/home/developer/myapp/config
#      export DATA_ROOT=/home/developer/myapp/data
#
#    Staging:
#      export DEPLOY_ENV=staging
#      export APP_ROOT=/opt/myapp
#      export CONFIG_ROOT=/etc/myapp/config
#      export DATA_ROOT=/var/lib/myapp-staging
#
#    Production:
#      export DEPLOY_ENV=production
#      export APP_ROOT=/opt/myapp
#      export CONFIG_ROOT=/etc/myapp/config
#      export DATA_ROOT=/var/lib/myapp
#
# 6. Testing this Configuration:
#
#    # Set environment variables
#    export DEPLOY_ENV=production
#    export APP_ROOT=/opt/myapp
#    export CONFIG_ROOT=/etc/myapp/config
#    export DATA_ROOT=/var/lib/myapp
#
#    # Create required directory structure (for testing)
#    mkdir -p /opt/myapp/{bin,web/{ssl,static},db/migrations/production,scripts,monitoring}
#    mkdir -p /etc/myapp/config/production
#    mkdir -p /var/lib/myapp/{logs/production,backups,db}
#
#    # Create placeholder files
#    touch /etc/myapp/config/production/{global.yml,secrets.enc,app.yml,database.yml,redis.yml}
#    touch /opt/myapp/{LICENSE,VERSION}
#    touch /opt/myapp/web/nginx.conf
#    touch /opt/myapp/web/ssl/{cert.pem,key.pem}
#    touch /opt/myapp/web/static/index.html
#    touch /opt/myapp/db/schema.sql
#    touch /opt/myapp/db/migrations/production/001_initial.sql
#    touch /var/lib/myapp/db/backup/.gitkeep
#    touch /opt/myapp/bin/{server,worker}
#    touch /var/lib/myapp/logs/production/.gitkeep
#    touch /opt/myapp/monitoring/{prometheus.yml,grafana-dashboard.json}
#    touch /var/lib/myapp/backups/.gitkeep
#    touch /opt/myapp/scripts/{backup.sh,restore.sh,migrate.sh,verify_schema.sh}
#
#    # Record hashes (assuming hash directory is /tmp/hashes)
#    ./build/record -d /tmp/hashes verify_files_expansion.toml
#
#    # Run the configuration
#    ./build/runner -d /tmp/hashes verify_files_expansion.toml
