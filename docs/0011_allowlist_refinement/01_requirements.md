# 要件定義書: Allowlist機能の短期的改善

## 1. プロジェクト概要

### 1.1 背景
現在のgo-safe-cmd-runnerの環境変数allowlist機能において、レビューで以下の具体的な問題が指摘されている：

1. **継承ロジックの不明確性**
   - `isVariableAllowed`関数の継承ロジックが複雑で理解しにくい
   - グループallowlist が nil の場合とグローバルallowlistの関係が不明確

2. **不適切なallowlistチェック**
   - コマンド固有環境変数（`Command.Env`）に対してもallowlistチェックが適用されている
   - 設定で明示的に定義した環境変数までが制限される不合理な状況

3. **設定検証の不足**
   - 設定ファイルの妥当性検証が不十分
   - 設定エラーの早期発見ができていない

### 1.2 目的
レビュー指摘事項に対する短期的な改善を行い、allowlist機能の実用性と理解しやすさを向上させる。

## 2. 機能要件

### 2.1 継承ロジックの明確化

#### 2.1.1 `isVariableAllowed`関数の改善
**現在の問題点** (`internal/runner/environment/filter.go:182`)：
```go
func (f *Filter) isVariableAllowed(variable string, groupAllowlist []string) bool {
    // If group allowlist is provided, use it exclusively (ignore global)
    if groupAllowlist != nil {
        return slices.Contains(groupAllowlist, variable)
    }
    // If no group allowlist provided, use global allowlist
    return f.globalAllowlist[variable]
}
```

**改善要件**：
- [ ] 継承ロジックを3段階に明確化：
  1. **明示的グループ設定**: `env_allowlist = ["VAR1", "VAR2"]` → グループ設定のみ使用
  2. **明示的拒否**: `env_allowlist = []` → すべて拒否（グローバル無視）
  3. **未定義（継承）**: `env_allowlist` フィールドなし → グローバル設定を継承

- [ ] nil と空スライスを明確に区別する実装
- [ ] 分かりやすい関数名への変更（例: `resolveAllowedVariable`）
- [ ] ログ出力で継承状況を明示

#### 2.1.2 設定状態の可視化
- [ ] どの設定が適用されているかのデバッグログ追加
- [ ] 継承関係の明確な表示
- [ ] 設定検証時の詳細情報出力

### 2.2 コマンド固有環境変数のallowlistチェック除外

#### 2.2.1 問題の特定
**現在の問題箇所** (`internal/runner/runner.go:398-401`)：
```go
allowed := r.envFilter.IsVariableAccessAllowed(variable, group)
if !allowed {
    return nil, fmt.Errorf("failed to resolve variable %s: %w", variable, ErrVariableAccessDenied)
}
```

**問題点**：
- 設定で明示的に定義した `Command.Env` の環境変数もallowlistでチェックされている
- ユーザーが設定した環境変数が「許可されていない」として拒否される不合理

#### 2.2.2 改善要件
- [ ] `Command.Env` で明示的に定義された環境変数はallowlistチェックを**除外**
- [ ] システム環境変数と.envファイル変数のみallowlistチェックを適用
- [ ] `Command.Env` の変数参照解決時は参照先の変数ソースに応じて制御：
  - [ ] システム環境変数参照 → allowlistチェック適用
  - [ ] .envファイル変数参照 → allowlistチェック適用
  - [ ] Command.Env変数参照 → allowlistチェック除外
- [ ] 明確な処理フローの実装：
  1. システム環境変数 → allowlistチェック
  2. .envファイル変数 → allowlistチェック
  3. `Command.Env`設定 → allowlistチェック**除外**

#### 2.2.3 セキュリティ考慮事項
**信頼度レベル別のセキュリティ制御**：
- [ ] **高信頼**: `Command.Env` で定義された変数
  - 設定ファイルで明示的に定義されているため信頼できる
  - allowlistチェックを除外し、基本的な安全性チェックのみ適用

- [ ] **部分的信頼**: システム環境変数、.envファイル変数
  - 外部から影響を受ける可能性があるため部分的信頼
  - allowlistチェックを適用してアクセス制御

**変数参照時のセキュリティ制御**：
- [ ] `Command.Env` 内での変数参照（`${VAR}`）時は参照先に応じて制御
- [ ] 参照先が信頼できないソースの場合はallowlistチェックを適用
- [ ] 参照解決に失敗した場合はエラーとして処理（明確な失敗通知）

**基本的安全性チェックの維持**：
- [ ] `Command.Env` の環境変数値に対する基本的な安全性チェック（dangerous patterns）は維持
- [ ] 変数名の妥当性検証は継続
- [ ] 設定ファイル自体のセキュリティは別途確保

### 2.3 設定検証機能の追加

#### 2.3.1 設定ファイル検証の強化
- [ ] 設定読み込み時の妥当性チェック機能
- [ ] allowlist設定の妥当性検証：
  - 空の変数名検出
  - 無効な変数名パターン検出
  - 重複エントリの警告
- [ ] グループとグローバル設定の整合性チェック

#### 2.3.2 実行前検証の実装
- [ ] コマンド実行前の環境変数参照検証
- [ ] 未定義変数の事前検出
- [ ] 循環参照の検出強化

#### 2.3.3 検証レポート機能
- [ ] 設定の問題点をまとめたレポート出力
- [ ] 推奨設定の提案
- [ ] セキュリティチェック結果の表示

## 3. 非機能要件

### 3.1 後方互換性
- 既存の設定ファイル形式を完全に維持
- 既存の動作を破壊しない（破壊的変更は行わない）
- 段階的な改善による影響最小化

### 3.2 保守性
- コードの理解しやすさの向上
- 明確な処理フローの実装
- 包括的なテストカバレッジ

### 3.3 ユーザビリティ
- 設定エラーの早期発見
- 分かりやすいエラーメッセージ
- デバッグ情報の充実

## 4. 技術的制約

### 4.1 実装制約
- Go 1.23.10 での動作保証
- 既存依存関係の維持（新たな外部依存追加なし）
- 既存テストの互換性維持

### 4.2 設計制約
- 現在のアーキテクチャを大きく変更しない
- 最小限の変更で最大の効果を目指す
- セキュリティレベルを下げない

## 5. 実装計画

### 5.1 Phase 1: 継承ロジックの明確化（期間: 2-3日）
1. `isVariableAllowed`関数の改善
   - [ ] nil と空スライスの区別実装
   - [ ] 継承ロジックの3段階明確化
   - [ ] 分かりやすい関数名への変更
   - [ ] 詳細なログ出力の追加

2. テストケースの追加
   - [ ] 継承パターンの網羅的テスト
   - [ ] エッジケースのテスト追加

### 5.2 Phase 2: コマンド固有環境変数の除外（期間: 2-3日）
1. `runner.go`の環境変数処理修正
   - [ ] `Command.Env`のallowlistチェック除外
   - [ ] 処理フローの明確化
   - [ ] セキュリティチェックの維持

2. 統合テストの更新
   - [ ] 新しい処理フローのテスト
   - [ ] セキュリティテストの確認

### 5.3 Phase 3: 設定検証機能の追加（期間: 2-3日）
1. 設定検証機能の実装
   - [ ] 設定読み込み時の妥当性チェック
   - [ ] allowlist設定の検証
   - [ ] 検証レポート機能

2. 検証機能のテスト
   - [ ] 各種検証パターンのテスト
   - [ ] エラーハンドリングのテスト

### 5.4 Phase 4: 統合テスト・文書化（期間: 1-2日）
1. 全体統合テスト
   - [ ] 全機能の動作確認
   - [ ] 既存機能の回帰テスト

2. ドキュメント更新
   - [ ] 設定例の更新
   - [ ] ユーザーガイドの更新

## 6. 成功基準

### 6.1 機能要件の達成
- [ ] `isVariableAllowed`関数の継承ロジックが明確になっている
- [ ] `Command.Env`の環境変数がallowlistチェックから除外されている
- [ ] 設定検証機能が正常に動作している

### 6.2 品質基準
- [ ] 既存テストがすべてパスしている
- [ ] 新機能のテストカバレッジが80%以上
- [ ] 既存の動作が破壊されていない

### 6.3 ユーザビリティ基準
- [ ] 継承関係が設定例で明確に説明されている
- [ ] エラーメッセージが改善されている
- [ ] 設定検証でエラーが早期発見できている

## 7. リスク分析

### 7.1 高リスク
- **既存機能の破壊**: 継承ロジック変更による既存動作の変化
  - 対策: 詳細なテストと段階的実装

### 7.2 中リスク
- **設定の複雑化**: 新しい検証機能による設定の複雑さ
  - 対策: シンプルなデフォルト動作と明確な文書化

### 7.3 低リスク
- **開発期間の延長**: 実装の複雑さによるスケジュール遅延
  - 対策: 最小限の変更に集中

## 8. 重要な設計原則

### 8.1 最小変更の原則
- 既存コードへの影響を最小限に抑制
- 新機能追加よりも既存機能の改善を優先
- 破壊的変更は行わない

### 8.2 明確性の原則
- 処理フローを明確にする
- 設定の継承関係を分かりやすくする
- エラーメッセージを具体的にする

### 8.3 実用性の原則
- ユーザーが実際に遭遇する問題を解決する
- 設定の使いやすさを向上させる
- デバッグを容易にする

## 9. 次のステップ

この要件定義書に基づき、以下の順序で進行する：

1. **アーキテクチャ設計書**: 具体的な実装方針の策定
2. **詳細仕様書**: 各機能の詳細仕様の定義
3. **実装**: 段階的な機能実装
4. **テスト**: 包括的なテストの実行
5. **文書化**: ユーザー向けドキュメントの更新
