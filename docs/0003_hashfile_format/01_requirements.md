# 要件定義書：ハッシュファイル形式のJSON化

## 1. 概要 (Overview)

**目的:** このドキュメントは、現在のテキスト形式のハッシュファイルをJSON形式に移行する要件を定義する。

**背景:**
現在の filevalidator は、ハッシュファイルを以下の単純なテキスト形式で保存している：
```
/absolute/path/to/file.txt
abc123def456...
```

この形式は拡張性に欠け、将来的な機能追加（タイムスタンプ、メタデータ、複数ハッシュアルゴリズム対応など）が困難である。構造化されたJSON形式への移行により、保守性と拡張性を向上させる必要がある。

## 2. 目的とスコープ (Goals and Scope)

### 2.1. 目的 (Goals)
このJSON化により達成する機能：

- 拡張性の向上：新しいフィールドの追加が容易
- バージョン管理：ファイル形式のバージョン管理による後方互換性の確保
- メタデータ対応：ハッシュ記録日時、形式識別子等の追加情報の保存
- 構造化：ハッシュアルゴリズムとハッシュ値の明確な分離
- 可読性の向上：人間が読みやすく、デバッグが容易な形式
- 検証可能性：JSONスキーマによる形式検証の可能性

### 2.2. スコープ (In Scope)
この実装で対応する機能範囲：

- 新しいJSON形式のハッシュファイル構造の定義
- JSON形式でのハッシュファイル書き込み機能
- 自動フォーマット検出機能
- 既存のテストの更新とJSON形式に対応したテスト追加
- JSON関連のエラーハンドリング
- バージョン管理機能

### 2.3. スコープ外 (Out of Scope)
この実装の対象外：

- JSON形式とレガシー形式の両方の読み込み対応
- 後方互換性の確保（レガシー形式の読み込みサポート）
- レガシー形式からJSON形式への自動変換機能
- JSONスキーマによる厳密な形式検証
- 複数のハッシュアルゴリズムの同時保存
- ハッシュファイルの暗号化
- 圧縮機能
- 外部ライブラリへの依存（標準ライブラリのみ使用）

## 3. 機能要件 (Functional Requirements)

### 3.1. JSON形式の定義

#### 3.1.1. 基本構造
```json
{
  "version": "1.0",
  "format": "file-hash",
  "timestamp": "2025-07-04T10:30:00Z",
  "file": {
    "path": "/absolute/path/to/file.txt",
    "hash": {
      "algorithm": "SHA256",
      "value": "abc123def456..."
    }
  }
}
```

#### 3.1.2. フィールド仕様
- `version`: ファイル形式のバージョン（必須）
- `format`: ファイル形式の識別子（必須、固定値："file-hash"）
- `timestamp`: ハッシュ記録日時（必須、RFC3339形式）
- `file.path`: 対象ファイルの絶対パス（必須）
- `file.hash.algorithm`: ハッシュアルゴリズム名（必須）
- `file.hash.value`: ハッシュ値（必須）

### 3.2. 読み込み機能

#### 3.2.1. フォーマット自動検出
- ファイル内容の先頭文字を確認してJSON形式かレガシー形式かを判定
- JSON形式の場合は `{` で始まる
- レガシー形式の場合は `/` で始まる（絶対パス）

#### 3.2.2. レガシー形式の読み込み
- 既存のテキスト形式（`path\nhash`）の読み込みはサポートしない

#### 3.2.3. JSON形式の読み込み
- 標準ライブラリの `encoding/json` を使用
- 必須フィールドの検証
- 不正な形式の場合は適切なエラーを返す

### 3.3. 書き込み機能

#### 3.3.1. JSON形式での書き込み
- 新しいハッシュファイルはすべてJSON形式で作成
- タイムスタンプの自動設定（現在日時）
- 整形されたJSON（インデント付き）での出力

#### 3.3.2. 既存ファイルの読み込み
- 既存のレガシー形式ファイルは読み込み時にエラーとする

## 4. 非機能要件 (Non-functional Requirements)

### 4.1. 性能要件
- JSON処理によるオーバーヘッドは最小限に抑制
- 大きなファイルパスでも効率的に処理
- メモリ使用量の増加は10%以内

### 4.2. セキュリティ要件
- JSONパースによる脆弱性の回避
- 標準ライブラリのみ使用（外部依存を避ける）
- 不正な形式のJSONでクラッシュしない

### 4.3. 互換性要件
- 既存のレガシー形式ファイルの読み込みはサポートしない
- 既存のAPIインターフェースは変更しない
- 既存のテストは引き続き通る

### 4.4. 可用性要件
- JSON形式の読み込みエラーは適切なエラーメッセージを提供
- レガシー形式の読み込みに対しては ErrInvalidHashFileFormat エラーを使用

## 5. 制約事項 (Constraints)

### 5.1. 技術的制約
- Go標準ライブラリのみ使用
- 既存のファイル操作セキュリティ機能を維持
- 既存のテストカバレッジを維持

### 5.2. 運用制約
- 既存のハッシュファイルディレクトリ構造は変更しない
- 既存のファイル名生成ロジックは変更しない
- 段階的な移行の検討は不要

## 6. 受け入れ基準 (Acceptance Criteria)

### 6.1. 機能的受け入れ基準
- [ ] 新しいJSON形式でハッシュファイルを作成できる
- [ ] レガシー形式のハッシュファイル読み込みはエラーとなる
- [ ] JSON形式のハッシュファイルを読み込める
- [ ] 既存のRecord/Verify機能が正常に動作する
- [ ] 既存のすべてのテストが通る
- [ ] 新しいJSON形式に対応したテストが追加されている
- [ ] レガシー形式に依存したテストは新しいJSON形式に対応したテストに置き換えられている。

### 6.2. 非機能的受け入れ基準
- [ ] 性能の劣化が10%以内に収まる
- [ ] メモリ使用量の増加が10%以内に収まる
- [ ] 不正なJSONでクラッシュしない
- [ ] 適切なエラーメッセージが表示される

## 7. 実装フェーズ (Implementation Phases)

### Phase 1: 基盤整備
- JSON構造体の定義
- 新しいエラータイプの追加
- 基本的なJSON読み書き機能の実装

### Phase 2: 書き込み機能の実装
- Record関数の更新（JSON形式での書き込み）
- タイムスタンプ自動設定機能

### Phase 3: 読み込み機能の実装
- JSON形式の両方に対応した読み込み

### Phase 4: テストの更新
- 既存テストの更新
- JSON形式に対応した新しいテスト追加

### Phase 5: 統合・検証
- 全体的な動作確認
- 性能テスト
- セキュリティテスト
