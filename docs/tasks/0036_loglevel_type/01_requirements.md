# Task 0036: LogLevel 型の導入

## 1. 背景

現在、`GlobalConfig.LogLevel` フィールドは `string` 型で定義されており、以下の問題があります:

1. **遅延エラー検出**: TOML 設定ファイル内でのタイポが実行時まで検出されない
2. **暗黙のフォールバック**: 無効なログレベルが指定された場合、警告を出力するものの INFO レベルにフォールバックして実行を継続する
3. **型安全性の欠如**: コード内で文字列リテラルを使用するため、タイポのリスクがある

### 現在の実装

```go
// GlobalConfig contains global configuration options
type GlobalConfig struct {
    LogLevel string `toml:"log_level"` // Log level (debug, info, warn, error)
    // ...
}
```

### 問題のあるシナリオ

```toml
[global]
log_level = "debg"  # タイポ - 実行時まで検出されない
```

現在の動作:
- TOML パースは成功
- ロガー初期化時にパースエラーが発生
- INFO レベルにフォールバックして実行継続
- 重要なデバッグログが出力されない可能性

## 2. 目的

LogLevel を専用のカスタム型として定義し、`encoding.TextUnmarshaler` インターフェースを実装することで、以下を実現する:

1. **早期エラー検出**: TOML パース時点で無効なログレベルを検出し、エラーを返す
2. **型安全性の向上**: 定数を使用することで、コード内でのタイポを防止
3. **明示的なバリデーション**: 許可される値を型定義とバリデーションロジックで明確化
4. **ユーザーエクスペリエンスの改善**: 設定エラーを早期に明確なエラーメッセージで通知

## 3. 要件

### 3.1 機能要件

#### FR-1: LogLevel 型の定義
- `LogLevel` 型を定義し、以下の定数を提供する:
  - `LogLevelDebug`: "debug"
  - `LogLevelInfo`: "info"
  - `LogLevelWarn`: "warn"
  - `LogLevelError`: "error"

#### FR-2: TOML パース時のバリデーション
- `encoding.TextUnmarshaler` インターフェースを実装し、TOML パース時に以下を検証:
  - 有効なログレベル (debug, info, warn, error) のみを受け入れる
  - 空文字列はデフォルト値 (info) として扱う
  - 無効な値に対しては、明確なエラーメッセージを返す

#### FR-3: slog.Level への変換
- `LogLevel` から `slog.Level` への変換メソッドを提供
- エラーハンドリングを含む安全な変換を実現

#### FR-4: 既存コードの更新
- `GlobalConfig.LogLevel` の型を `string` から `LogLevel` に変更
- `bootstrap.LoggerConfig.Level` の型を更新
- コマンドライン引数の処理を更新

### 3.2 非機能要件

#### NFR-1: 後方互換性
- TOML 設定ファイルの形式は変更しない (値は文字列のまま)
- 既存の有効な設定ファイルはそのまま動作する

#### NFR-2: エラーメッセージの品質
- 無効なログレベルが指定された場合、以下を含むエラーメッセージを提供:
  - 指定された無効な値
  - 許可される有効な値のリスト

#### NFR-3: パフォーマンス
- TOML パース時のオーバーヘッドは無視できる程度に抑える
- 実行時のログレベル判定に影響を与えない

### 3.3 制約

#### C-1: 既存の設計との整合性
- 他の設定フィールド (`RiskLevel` など) と同様のパターンを踏襲
- `slog` パッケージの標準的な使用方法を維持

#### C-2: テストカバレッジ
- 新規コードのテストカバレッジは 100% を目指す
- エッジケース (空文字列、無効な値、大文字小文字の違い等) をカバー

## 4. 成功基準

1. **早期検出**: 無効なログレベルを含む TOML ファイルをパースした際、エラーが返される
2. **型安全性**: コード内で `LogLevel` 定数を使用でき、IDE の補完が効く
3. **明確なエラー**: エラーメッセージに無効な値と有効な値のリストが含まれる
4. **既存動作の維持**: 既存の有効な設定ファイルがすべて正常に動作する
5. **テストカバレッジ**: 新規コードのテストカバレッジが 100%

## 5. スコープ外

以下は今回のスコープに含まない:

1. **コマンド/グループレベルのログレベル**: グローバルレベルのみを対象とする
2. **動的なログレベル変更**: 実行時のログレベル変更機能は追加しない
3. **カスタムログレベル**: slog の標準ログレベル (Debug, Info, Warn, Error) のみをサポート
4. **他の文字列フィールドの型化**: LogLevel のみを対象とし、他のフィールド (例: MaxRiskLevel) は別タスクで対応

## 6. 参考情報

### 関連する既存の実装

- `RiskLevel` 型: [runnertypes/config.go:163-234](../../../internal/runner/runnertypes/config.go#L163-L234)
  - 同様のカスタム型 + バリデーションのパターン
  - `ParseRiskLevel()` による文字列からの変換

### Go 標準ライブラリ

- `encoding.TextUnmarshaler` インターフェース
- `log/slog.Level` 型と `UnmarshalText()` メソッド

## 7. 依存関係

### 前提条件
- なし (独立したタスク)

### ブロッカー
- なし

### 関連タスク
- Task 0035: Spec/Runtime 分離 (LogLevel は GlobalSpec に配置される可能性)
