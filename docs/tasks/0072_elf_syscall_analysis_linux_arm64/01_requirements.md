# ELF 機械語解析による syscall 静的解析（Linux/arm64 対応）要件定義書

## 1. 概要

### 1.1 背景

タスク 0070（ELF 機械語解析による syscall 静的解析）では、x86_64 アーキテクチャの静的リンクされた ELF バイナリを対象にネットワーク関連 syscall の検出を実装した。

Apple Silicon Mac（M シリーズ）や AWS Graviton 等の arm64 (aarch64) 環境が普及しており、これらの環境でビルドされた Go バイナリも同様の解析対象となる。arm64 Linux では syscall の呼び出し規約が x86_64 と異なるため、専用の解析ロジックが必要である。

### 1.2 arm64 Linux における syscall の仕組み

arm64 Linux における syscall の呼び出し規約は x86_64 と以下の点で異なる：

| 項目 | x86_64 | arm64 Linux |
|------|--------|-------------|
| 命令 | `syscall` (オペコード `0F 05`) | `svc #0` (エンコード `0xd4000001`) |
| syscall 番号レジスタ | `eax`/`rax` | `w8`/`x8` |
| 引数レジスタ | `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9` | `x0`–`x5` |

arm64 Linux では `svc #0` 命令を使用してカーネルに syscall を発行し、syscall 番号は `w8`（または `x8`）レジスタで渡す。

#### arm64 における即値設定パターン

arm64 では `w8` への即値設定には以下のパターンがある：

```asm
mov  w8, #198      // MOVZ: 16ビット範囲(0-65535)の即値設定（多くの syscall 番号で使用）
svc  #0
```

```asm
mov  w8, #242      // accept4(242) なども MOVZ で設定可能
svc  #0
```

`ORR Xn, XZR, #imm` パターン（ビットマスク即値）は、syscall 番号として使われる小さな値（0〜500 程度）では通常現れないため、本タスクのスコープ外とする。

### 1.3 Go バイナリにおける arm64 syscall の仕組み

Go バイナリでは x86_64 と同様に `syscall` パッケージ等のラッパー関数を経由して syscall を発行する。arm64 における Go のラッパー関数のシグネチャとレジスタ割り当ては x86_64 と同一（Go 1.17+ レジスタベース ABI）である。ただし、引数を渡すレジスタが異なる：

- **arm64**: 第1引数（syscall 番号）は `x0` レジスタで渡される
- **x86_64**: 第1引数（syscall 番号）は `rax` レジスタで渡される

arm64 の Go ラッパー呼び出しパターン例：

```asm
mov  x0, #198      // syscall 番号 (socket=198) を x0 に設定
bl   syscall.Syscall
```

arm64 における制御フロー命令：`b`, `bl`, `blr`, `br`, `ret`, `cbz`, `cbnz`, `tbz`, `tbnz`

### 1.4 目的

タスク 0070 の実装を arm64 Linux アーキテクチャに拡張し、arm64 ELF バイナリに対しても同等のネットワーク関連 syscall 静的解析を可能にする。

### 1.5 スコープ

- **対象**: arm64 Linux の静的リンクされた ELF バイナリ（Go バイナリ等）
- **対象外**: macOS (Mach-O 形式)、非 ELF ファイル
- **前提**: タスク 0070 の実装が完了していること

## 2. 用語定義

| 用語 | 定義 |
|------|------|
| `svc #0` 命令 | arm64 Linux でカーネルに syscall を発行する命令（エンコード `0xd4000001`） |
| arm64asm | `golang.org/x/arch/arm64/arm64asm` パッケージ。arm64 機械語のデコード機能を提供する Go 準公式ライブラリ |
| `w8`/`x8` レジスタ | arm64 Linux における syscall 番号レジスタ（`w8` は `x8` の 32 ビットビュー） |
| `MOVZ` | arm64 の即値設定命令。16 ビット即値をゼロ拡張してレジスタに設定する |
| `BL` | arm64 の Branch with Link 命令。関数呼び出しに使用する（x86_64 の `CALL` に相当） |

## 3. 機能要件

### 3.1 arm64 機械語デコーダーの実装

#### FR-3.1.1: arm64 機械語デコード

`golang.org/x/arch/arm64/arm64asm` パッケージを使用して arm64 機械語をデコードできること。

arm64 は固定長命令（4 バイト）であるため、x86_64 のような可変長命令に起因するデコード失敗リカバリは不要である。

#### FR-3.1.2: `svc #0` 命令の検出

デコードされた命令列から `svc #0` 命令を検出できること。

**注記**: arm64 では `svc` 命令のオペランドに任意の 16 ビット即値を指定できるが、Linux カーネルへの syscall は慣習的に `svc #0` （即値=0）を使用する。本実装では `svc #0`（`Op == SVC` かつオペランド即値 == 0）のみを対象とする。

#### FR-3.1.3: w8/x8 への即値設定の検出

`svc #0` 命令から逆方向にスキャンし、`w8`/`x8` レジスタを最初に変更している命令を探す。その命令が即値設定であれば、syscall 番号として抽出できること。

**対象パターン（arm64）**:

```asm
mov  w8, #198      // MOVZ: syscall 番号 198 (socket) を設定
svc  #0
```

`arm64asm` パッケージでは `mov w8, #198` は `MOVZ` 命令としてデコードされる。

**走査ルール**（x86_64 と同様）:
1. `svc #0` 命令の位置から逆方向に 1 命令ずつ遡る
2. `w8`/`x8` を変更する命令を発見した時点で走査を終了する
3. N 命令以内に `w8`/`x8` を変更する命令が見つからない場合は「番号不明」とする
4. 制御フロー命令（`b`, `bl`, `blr`, `br`, `ret`, `cbz`, `cbnz`, `tbz`, `tbnz`）を超えた走査は行わない

#### FR-3.1.4: 間接設定の high risk 判定

x86_64 の FR-3.1.4 と同一の判定ロジックを適用すること（即値設定でない場合、スキャン範囲内に変更命令が見つからない場合、制御フロー命令に到達した場合は high risk）。

#### FR-3.1.5: ネットワーク関連 syscall の判定

arm64 Linux の syscall 番号でネットワーク関連 syscall を判定すること。

**注記**: arm64 Linux の syscall 番号は x86_64 と異なる。

| syscall | 番号 (arm64 Linux) | 意味 |
|---------|---------------------|------|
| `socket` | 198 | ソケット作成 |
| `bind` | 200 | アドレスにバインド |
| `listen` | 201 | 接続待ち受け |
| `accept` | 202 | 接続受け入れ |
| `connect` | 203 | 接続 |
| `sendto` | 206 | データ送信 |
| `recvfrom` | 207 | データ受信 |
| `sendmsg` | 211 | メッセージ送信 |
| `recvmsg` | 212 | メッセージ受信 |
| `accept4` | 242 | 接続受け入れ（フラグ付き） |

#### FR-3.1.6: Go syscall ラッパーの解析（arm64）

arm64 における Go の `syscall.Syscall` 等のラッパー関数への `bl` 呼び出しを解析できること。

arm64 では Go の register-based ABI（Go 1.17+）において syscall 番号の第1引数は `x0` レジスタで渡される。

**arm64 の Go ラッパー呼び出しパターン**:
```asm
mov  x0, #198      // syscall 番号 (socket=198) を x0 に設定
bl   syscall.Syscall
```

`bl` 命令（arm64asm では `BL` Op）はアドレスへの直接分岐（x86_64 の `CALL` に相当）として扱う。

**注記**: arm64 における `bl` のオペランドは `arm64asm.PCRel` 型であり、現在の命令アドレスからの相対オフセットを表す。ターゲットアドレスの計算方法は x86_64 の `x86asm.Rel` と類似しているが、詳細は設計フェーズで確認すること。

### 3.2 既存インターフェースへの統合

#### FR-3.2.1: MachineCodeDecoder インターフェースの実装

既存の `MachineCodeDecoder` インターフェースを arm64 用に実装した `ARM64Decoder` 構造体を提供すること。

インターフェースのメソッド対応：

| メソッド | x86_64 対応 | arm64 対応 |
|----------|-------------|------------|
| `IsSyscallInstruction` | `SYSCALL` 命令を検出 | `SVC` 命令かつオペランド=0 を検出 |
| `ModifiesW8orX8`（仮称）| `eax`/`rax` の変更を検出 | `w8`/`x8` の変更を検出 |
| `IsImmediateMove` | `MOV EAX, imm` を検出 | `MOVZ W8, imm` を検出 |
| `IsControlFlowInstruction` | `JMP`, `CALL`, `RET` 等を検出 | `B`, `BL`, `BLR`, `BR`, `RET`, `CBZ`, `CBNZ`, `TBZ`, `TBNZ` を検出 |

**注記**: 既存の `MachineCodeDecoder` インターフェースのメソッド名 `ModifiesEAXorRAX` は x86_64 固有の名称となっている。arm64 対応に際してインターフェースのリファクタリング（メソッド名の汎用化）が必要な場合は、設計フェーズで判断すること。

#### FR-3.2.2: SyscallNumberTable インターフェースの実装

既存の `SyscallNumberTable` インターフェースを arm64 Linux 用に実装した `ARM64LinuxSyscallTable` 構造体を提供すること。

#### FR-3.2.3: SyscallAnalyzer のアーキテクチャ対応

`SyscallAnalyzer` が arm64 ELF バイナリを受け取った場合に、arm64 用のデコーダーと syscall テーブルを使用して解析を実行できること。

現在の `SyscallAnalyzer.AnalyzeSyscallsFromELF` は `elf.EM_X86_64` のみを受け付けて `UnsupportedArchitectureError` を返す。arm64 (`elf.EM_AARCH64`) も受け付けられるよう拡張すること。

#### FR-3.2.4: GoWrapperResolver のアーキテクチャ対応

arm64 における Go syscall ラッパー解析を行う `ARM64GoWrapperResolver` を実装すること（または既存 `GoWrapperResolver` を arm64 対応に拡張すること）。

x86_64 との相違点：
- `bl` 命令（`BL` Op）を `call` 命令の代わりに検出する
- 第1引数レジスタが `x0` であること（x86_64 は `rax`/`eax`）
- 命令デコードに `arm64asm` を使用すること

### 3.3 解析結果の保存と利用

解析結果の保存・読み込みおよび runner 実行時の利用は、タスク 0070 の実装（`fileanalysis` パッケージ等）をそのまま使用する。`SyscallAnalysisResultCore.Architecture` フィールドに `"arm64"` を設定することで、アーキテクチャ別の解析結果を区別できる。

## 4. 非機能要件

### 4.1 パフォーマンス

arm64 は固定長命令（4 バイト）であるため、x86_64 より単純にデコードできる。タスク 0070 の NFR-4.1.2 と同等のパフォーマンス目標を維持すること。

### 4.2 保守性

#### NFR-4.2.1: アーキテクチャ分離

x86_64 と arm64 のデコーダー実装を明確に分離し、将来的な他アーキテクチャ追加が容易な設計とすること。

#### NFR-4.2.2: 外部ツールへの依存排除

タスク 0070 同様、arm64 の機械語デコードも Go ライブラリのみを使用し、外部コマンドへの依存を持たないこと。

## 5. 受け入れ条件

### AC-1: arm64 svc 命令の検出

- [ ] arm64 ELF バイナリの実行可能セクションから `svc #0` 命令を正しく検出できること
- [ ] `svc #0` 命令から逆方向にスキャンし、`w8`/`x8` への即値設定を抽出できること
- [ ] `movz w8, #198` のような即値設定命令を正しく検出できること

### AC-2: arm64 ネットワーク関連 syscall の判定

- [ ] `socket`(198), `connect`(203) 等の arm64 Linux ネットワーク関連 syscall 番号が検出された場合、ネットワーク操作ありと判定されること
- [ ] ネットワーク関連以外の syscall 番号のみが検出された場合、ネットワーク操作なしと判定されること
- [ ] x86_64 の syscall 番号（41 等）と arm64 の syscall 番号（198 等）が独立したテーブルで管理されること

### AC-3: arm64 間接設定の high risk 判定

- [ ] スキャン範囲内で `w8`/`x8` を変更する命令が即値設定でない場合、high risk と判定されること
- [ ] 制御フロー命令（`b`, `bl`, `ret` 等）に到達した場合、high risk と判定されること

### AC-4: arm64 Go ラッパー解析

- [ ] `syscall.Syscall` 等の標準ラッパー関数を使用している arm64 Go バイナリにおいて、ネットワーク操作の有無を正しく判定できること
- [ ] `bl syscall.Syscall` の直前で `x0` レジスタへの即値設定を検出できること

### AC-5: アーキテクチャ判定

- [ ] arm64 ELF バイナリ（`elf.EM_AARCH64`）に対して arm64 用の解析が実行されること
- [ ] x86_64 ELF バイナリ（`elf.EM_X86_64`）に対して既存の x86_64 解析が引き続き実行されること
- [ ] 非対応アーキテクチャ（例: RISC-V、MIPS）に対して `UnsupportedArchitectureError` が返されること

### AC-6: 既存機能への非影響

- [ ] x86_64 の既存テストがすべてパスすること
- [ ] 解析結果ファイルの保存・読み込みが両アーキテクチャで正しく動作すること

## 6. テスト方針

### 6.1 ユニットテスト

テスト用の arm64 バイト列（機械語）を直接デコーダーに渡してテストする。

- `movz w8, #198` + `svc #0` → socket(198) を検出
- `movz w8, #203` + `svc #0` → connect(203) を検出
- `mov x8, x0` + `svc #0` → 間接設定、high risk と判定
- `bl <addr>` + `svc #0` → 制御フロー境界、high risk と判定
- `movz w8, #1` + `svc #0` → write(1)、非ネットワーク
- arm64 Go ラッパー呼び出し: `movz x0, #198` + `bl <wrapper_addr>` → socket(198) を検出

### 6.2 統合テスト

テスト環境に arm64 クロスコンパイラまたは arm64 ネイティブ環境が存在する場合のみ実行：

1. 小さな Go プログラム（`net.Dial` 等を使うもの）を arm64 向けにクロスコンパイル
2. 事前解析を実行
3. socket/connect 等の syscall が検出されることを確認

arm64 ネイティブ環境がない場合でも `GOARCH=arm64 GOOS=linux go build` でクロスコンパイルが可能なため、CI 環境（x86_64）でも統合テストを実行できる。

## 7. 設計上の制約と限界

1. **macOS 非対応**: macOS (Darwin) の arm64 バイナリは Mach-O 形式であり ELF ではないため、本実装の対象外となる。macOS 上でも `GOOS=linux GOARCH=arm64` でクロスコンパイルした Linux バイナリは解析対象となる。

2. **arm64 固定長命令**: arm64 の命令は固定長（4 バイト）であるため、デコード失敗時のバイトスキップリカバリは不要。ただし、セクション先頭がアライメントされていない場合は 4 バイトアライメントで開始する。

3. **`bl` ターゲットアドレス計算**: arm64 の `bl` 命令のターゲットは `arm64asm.PCRel` 型で表現される相対オフセット。ターゲットアドレスの計算と既知ラッパー関数アドレスとのマッチングは設計フェーズで詳細を確認すること。

4. **`BLR` 命令**: `blr xN`（レジスタ間接呼び出し）は制御フロー命令の一種であり、FR-3.1.3 の走査ルール 4 に従い逆方向スキャンの境界となる。スキャン中に `blr` に到達した時点で `w8`/`x8` への即値設定が未確定の場合は、FR-3.1.4 に従い high risk と判定する。

5. **間接的なレジスタ設定**: x86_64 同様、`w8`/`x8` が即値設定以外の方法（レジスタコピー、メモリロード等）で設定される場合は high risk として扱う。

## 8. タスク 0070 との関係

| 項目 | タスク 0070 (x86_64) | 本タスク (arm64) |
|------|---------------------|-----------------|
| syscall 命令 | `syscall` (0F 05) | `svc #0` |
| syscall 番号レジスタ | `eax`/`rax` | `w8`/`x8` |
| Go ラッパー第1引数 | `rax`/`eax` | `x0` |
| 関数呼び出し命令 | `CALL` | `BL` |
| 命令長 | 可変長（1〜15 バイト）| 固定長（4 バイト）|
| デコードライブラリ | `golang.org/x/arch/x86/x86asm` | `golang.org/x/arch/arm64/arm64asm` |
| syscall 番号テーブル | x86_64 Linux テーブル | arm64 Linux テーブル |
| 解析結果の保存形式 | 共通（`fileanalysis` パッケージ）| 共通（`fileanalysis` パッケージ）|
