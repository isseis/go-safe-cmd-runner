# 実装計画書：ハイブリッドハッシュファイル名エンコーディング

## 1. 既存コードとの関係分析

### 1.1. 既存コードベース分析結果

- **HashFilePathGetter インターフェース**: `internal/filevalidator/validator.go:42-45` で既に定義済み
- **ProductionHashFilePathGetter**: `internal/filevalidator/validator.go:47-61` で既存実装済み（SHA256ベース）
- **Hash関連エラー**: `internal/filevalidator/errors.go` で定義済み
- **ロガー**: `internal/runner/audit/logger.go` で slog ベースのロガーが存在
- **FileSystem**: `internal/verification/types.go` および関連ファイルで抽象化済み

### 1.2. 重複回避戦略

1. **HashFilePathGetter インターフェースを再利用**（新規定義しない）
2. **既存エラータイプを拡張**（完全に新規作成しない）
3. **slog ベースのロガーを利用**（独自ロガーインターフェースを定義しない）
4. **既存のファイルシステム抽象化を使用**

### 1.3. 実装戦略

1. **段階的実装**: 破壊的変更を最小限に抑制
2. **後方互換性**: テスト環境での互換性維持
3. **セキュリティ優先**: プロダクション環境のセキュリティ最大化
4. **品質保証**: 包括的なテストと検証

## 2. 段階的実装計画

### ✅ 完了したフェーズ: エンコーディングコア機能（シンプル化版）

#### ✅ 1.1. エンコーディングパッケージ基盤作成
- **場所**: `internal/filevalidator/encoding/`
- **実装済みファイル**:
  - `substitution_hash_escape.go` - メインエンコーダー（最適化済み）
  - `encoding_result.go` - Result構造体
  - `errors.go` - エラータイプ定義
- **特徴**:
  - パス検証の厳格化（正規化済み絶対パスのみ受け付け）
  - シングルパス最適化済み
  - 分析機能は削除（シンプル化）

#### ✅ 1.2. 基本エンコード関数実装
- **実装済み機能**:
  - `Encode()` - エラー処理付きエンコード関数
  - `Decode()` - エラー処理付きデコード関数
  - `encodeOptimized()` - シングルパス最適化エンコード
  - `decodeOptimized()` - シングルパス最適化デコード
- **特徴**:
  - エラーハンドリングの強化
  - パフォーマンス最適化
  - セキュリティ重視の入力検証

#### ✅ 1.3. フォールバック機能実装
- **実装済み機能**:
  - `EncodeWithFallback()` - ハイブリッド機能の中核
  - `generateSHA256Fallback()` - SHA256フォールバック
  - `IsNormalEncoding()` / `IsFallbackEncoding()` - 判定機能
- **特徴**:
  - 長いパス自動検出
  - SHA256フォールバック常時有効
  - Result構造体による詳細情報提供

### 次のフェーズ: テスト強化とドキュメント

#### [x] 2.1. テストカバレッジ向上
- **場所**: `internal/filevalidator/encoding/substitution_hash_escape_test.go`
- **強化項目**:
  - エラーケースの網羅
  - 境界値テスト
  - ラウンドトリップテスト
- **戦略**: 既存実装の品質保証を最優先

#### [x] 2.2. パフォーマンス検証
- **完了**: ベンチマークテスト実装
- **完了**: メモリ使用量測定
- **完了**: パフォーマンス回帰検出
- **結果**: 目標を大幅に上回る性能（390倍のスループット、0.12MB/1000paths）
- **戦略**: 最適化済み実装の効果測定完了

#### [x] 2.3. ドキュメント整備
- **コード内ドキュメント完備**
- **戦略**: 実装の安全な利用促進
- 対象が内部ライブラリのため、以下の文書は作成しないことを決定
  - **使用例とベストプラクティス**
  - **エラーハンドリングガイド**

### 最終フェーズ: プロダクション統合とハイブリッド方式移行

#### [ ] 3.1. HybridHashFilePathGetter 実装
- **場所**: `internal/filevalidator/hybrid_hash_path_getter.go`
- **機能**:
  - `HashFilePathGetter` インターフェースの実装
  - `SubstitutionHashEscape` エンコーディングの統合
  - 従来SHA256方式との互換性維持
  - エラーハンドリングとロギング
- **戦略**: 既存の `ProductionHashFilePathGetter` を段階的に置換

#### [ ] 3.2. record, verify, runner コマンドでの統合
- **record コマンド**:
  - `HybridHashFilePathGetter` の使用に切り替え
  - 既存ハッシュファイルとの競合検出機能
  - 新方式ハッシュファイル生成の確認
- **verify コマンド**:
  - 新旧両方式のハッシュファイル対応
  - フォールバック検証機能
  - エラーメッセージの改善
- **runner コマンド**:
  - `verification.Manager` での新方式使用
  - 設定ファイル検証での新方式対応
  - パフォーマンス測定とログ出力

#### [ ] 3.3. 移行戦略と互換性維持
- **後方互換性**:
  - 既存SHA256ハッシュファイルの読み取り継続サポート
  - 新規作成は新方式を使用
  - 段階的移行のためのフラグ提供
- **移行プロセス**:
  - 既存ハッシュファイル検出・移行ツール
  - バッチ移行スクリプト
  - 移行前後の整合性チェック
- **設定オプション**:
  - 環境変数 `SAFE_CMD_RUNNER_HASH_ENCODING` で方式選択
  - デフォルトはハイブリッド方式（新方式）
  - 従来方式への切り戻し機能

#### [ ] 3.4. プロダクション検証とモニタリング
- **パフォーマンス測定**:
  - ハッシュファイル生成速度の比較
  - ファイルシステム使用量の監視
  - メモリ使用量の測定
- **安全性検証**:
  - ハッシュ衝突の検出とレポート
  - ファイル名長制限の遵守確認
  - エラーケースの包括的テスト
- **運用監視**:
  - 新旧方式の使用率追跡
  - エラー発生率の監視
  - パフォーマンス回帰の早期検出

## 3. 実装の詳細事項

### 3.1. 実装済みの主要コンポーネント

```go
// 新規パッケージ
package encoding

// 構造体ベースの実装（シンプル化）
type SubstitutionHashEscape struct{}

// 主要関数（エラー処理付き）
func (e *SubstitutionHashEscape) Encode(path string) (string, error)
func (e *SubstitutionHashEscape) Decode(encoded string) (string, error)
func (e *SubstitutionHashEscape) EncodeWithFallback(path string) Result

// 結果構造体
type Result struct {
    EncodedName    string
    IsFallback     bool
    OriginalLength int
    EncodedLength  int
}
```

### 3.2. 実装済みエラータイプ

```go
// errors.go で定義済み
var (
    ErrEmptyPath = errors.New("empty path")
    ErrNotAbsoluteOrNormalized = errors.New("path is not absolute or normalized")
)

type ErrInvalidPath struct {
    Path string
    Err  error
}

type ErrFallbackNotReversible struct {
    EncodedName string
}
```

### 3.3. 実装における主な改善点

- **パス検証の厳格化**: 正規化済み絶対パスのみ受け付け
- **シングルパス最適化**: エンコード・デコードを1回のループで実行
- **エラーハンドリング強化**: 詳細なエラー情報提供
- **分析機能削除**: シンプル化のため複雑な分析機能は削除

## 4. テスト戦略

### 4.1. ユニットテスト
- **各関数の単体テスト**
- **エラーケースの網羅**
- **境界値テスト**
- **HybridHashFilePathGetter の単体テスト**
- **移行シナリオの単体テスト**

### 4.2. 統合テスト
- **既存Validatorとの結合**
- **ファイルシステム操作**
- **移行シナリオ**
- **record/verify/runner コマンドでの統合テスト**
- **新旧方式の共存テスト**

### 4.3. パフォーマンステスト
- **エンコード・デコード速度**
- **メモリ使用量**
- **大量ファイル処理**
- **新旧方式のパフォーマンス比較**
- **移行処理のパフォーマンス測定**

### 4.4. プロパティベーステスト
- **エンコード/デコードの可逆性**
- **決定論的動作**
- **ユニークネス保証**
- **新旧方式間の整合性**

### 4.5. エンドツーエンドテスト
- **record → verify の完全サイクル（新方式）**
- **runner での設定ファイル検証（新方式）**
- **既存ハッシュファイルとの互換性確認**
- **移行プロセスの完全テスト**

### 4.6. 受け入れテスト
- **コマンドライン操作の正常動作**
- **エラーメッセージの適切性**
- **パフォーマンス要件の達成**
- **セキュリティ要件の遵守**

## 5. リスク管理

### 5.1. 技術的リスク
- **既存システムとの互換性**: 段階的移行で対応
- **パフォーマンス劣化**: ベンチマークテストで監視
- **エッジケース**: 豊富なテストケースで対応
- **ハッシュ衝突**: 新方式でのコリジョン検出強化
- **ファイル名長制限**: プラットフォーム固有制限の事前検証

### 5.2. 移行リスク
- **データ損失**: バックアップ機能を強制実装
- **ダウンタイム**: 手動移行のみサポート
- **ロールバック**: 既存ファイルの保持
- **部分移行**: 新旧混在状態での動作保証
- **移行失敗**: 移行プロセスの中断・再開機能

### 5.3. 運用リスク
- **設定間違い**: 環境変数設定の検証とデフォルト値
- **監視不備**: 新方式での問題検出の仕組み整備
- **デバッグ困難**: 新方式特有の問題の診断ツール

## 6. 成功基準

### 6.1. 実装済み機能要件
- [x] **コアエンコーディング機能**: Encode/Decode関数の実装
- [x] **SHA256フォールバック機能**: 長いパス自動検出・フォールバック
- [x] **エンコード/デコードの可逆性**: 通常エンコードの完全可逆性
- [x] **パス検証の厳格化**: 正規化済み絶対パスのみサポート

### 6.2. 実装済み品質要件
- [x] **エラーハンドリング強化**: 詳細なエラー情報とWrap対応
- [x] **パフォーマンス最適化**: シングルパス最適化済み
- [x] **コード品質**: リンターエラー解消
- [x] **シンプル化**: 複雑な分析機能削除

### 6.3. 今後の要件（フェーズ2）
- [ ] **テストカバレッジ向上**: 90% 以上
- [ ] **ベンチマークテスト実装**: パフォーマンス測定
- [ ] **ドキュメント完備**: 使用例とベストプラクティス
- [ ] **統合テスト**: 実際の使用シナリオでの検証

### 6.4. 最終目標要件（フェーズ3）
- [ ] **HybridHashFilePathGetter実装**: HashFilePathGetterインターフェース準拠
- [ ] **record/verify/runnerコマンド統合**: 全コマンドでの新方式サポート
- [ ] **後方互換性維持**: 既存ハッシュファイルの継続サポート
- [ ] **移行ツール提供**: 既存環境からの段階的移行サポート
- [ ] **パフォーマンス要件達成**: 従来方式と同等以上の性能
- [ ] **エラーハンドリング改善**: 分かりやすいエラーメッセージ
- [ ] **設定柔軟性**: 環境変数による方式選択機能
- [ ] **監視・デバッグ機能**: 運用時の問題診断支援

### 6.5. 品質ゲート
- **機能テスト**: 全テストスイートのパス（95%以上）
- **パフォーマンステスト**: 従来比で5%以内の性能差
- **互換性テスト**: 既存ハッシュファイルの100%互換性
- **セキュリティテスト**: ハッシュ衝突耐性の検証
- **運用テスト**: 移行プロセスの安全性確認

## 7. 実装状況とその後の方針

### 7.1. 実装完了事項
- ✅ **コアエンコーディング機能**: 最適化済みエンコード・デコード実装
- ✅ **フォールバック機能**: SHA256フォールバック自動選択
- ✅ **エラーハンドリング**: 厳密なパス検証とエラー処理
- ✅ **パフォーマンス最適化**: シングルパス処理による高速化

### 7.2. 次の優先アクション（フェーズ2）
1. **テストカバレッジ向上**: 包括的なテストケース作成
2. **ベンチマークテスト**: パフォーマンス測定と検証
3. **ドキュメント整備**: 使用方法とベストプラクティス文書化
4. **統合準備**: 実際のValidatorとの統合検討

### 7.3. 最終実装アクション（フェーズ3）
1. **HybridHashFilePathGetter実装**:
   - 既存 `HashFilePathGetter` インターフェースの実装
   - `SubstitutionHashEscape` エンコーディングの統合
   - 従来SHA256方式との互換性維持機能
2. **コマンド統合**:
   - record: 新方式でのハッシュファイル作成
   - verify: 新旧両方式の検証サポート
   - runner: verification.Manager での新方式使用
3. **移行サポート**:
   - 環境変数 `SAFE_CMD_RUNNER_HASH_ENCODING` による方式選択
   - 既存ハッシュファイルの検出・移行ツール
   - バッチ移行スクリプトの提供
4. **運用監視**:
   - パフォーマンス測定とログ出力
   - エラー監視とアラート機能
   - デバッグサポートツール

### 7.4. 長期的な方針
- **段階的な統合**: 破壊的変更を避けた漸進的移行
- **移行サポート**: 既存環境からの安全な移行プロセス
- **品質保証**: 包括的なテストと継続的監視
- **後方互換性**: 既存システムとの長期サポート

### 7.5. 成功指標
- **機能達成**: record/verify/runnerコマンドでの新方式完全サポート
- **互換性**: 既存ハッシュファイルとの100%互換性維持
- **性能**: 従来方式と同等以上のパフォーマンス
- **安全性**: ハッシュ衝突耐性とセキュリティ要件遵守
- **運用性**: 問題発生時の迅速な診断・対応能力

この計画により、コアエンコーディング機能から始まり、最終的にはrecord, verify, runnerコマンドでの完全なハイブリッド方式移行を段階的に実現します。
