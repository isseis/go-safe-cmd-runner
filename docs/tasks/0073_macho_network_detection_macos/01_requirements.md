# Mach-O バイナリ解析によるネットワーク操作検出（macOS 対応）要件定義書

## 1. 概要

### 1.1 背景

タスク 0069（ELF `.dynsym` 解析）および タスク 0070/0072（ELF 機械語 syscall 解析）は、Linux ELF バイナリを対象としたネットワーク操作検出を実装した。

macOS（Darwin）上の実行ファイルは ELF ではなく **Mach-O 形式**を使用する。Apple Silicon Mac（M シリーズ）の普及により、macOS arm64 環境でビルドされたバイナリも解析対象となるケースが増えている。macOS バイナリは ELF と異なるバイナリ形式・syscall 規約・ネットワーク API 呼び出し方式を持つため、専用の解析ロジックが必要である。

### 1.2 macOS バイナリにおけるネットワーク操作の仕組み

#### 1.2.1 バイナリ形式

macOS の実行ファイルは Mach-O 形式（単一アーキテクチャ）または Fat バイナリ形式（複数アーキテクチャを1ファイルに格納）を使用する。

#### 1.2.2 ネットワーク API の呼び出し方式

macOS では、ユーザーランドプログラムは原則として `libSystem.dylib`（macOS の標準 C ライブラリ）を経由してシステムコールを発行する。

- **動的リンクバイナリ（C/C++ 等）**: `libSystem.dylib` の `socket()`, `connect()` 等を動的リンク。インポートシンボルテーブル（`LC_DYLD_INFO` / `__LINKEDIT` セグメント）に関数名が記録される。
- **Go バイナリ**: Go ランタイムが内部的に `libSystem.dylib` の関数を呼び出す。Go は macOS 上でも `libSystem.dylib` にリンクするため、動的シンボル解析でネットワーク関連シンボルを検出できる。

#### 1.2.3 macOS における直接 syscall の扱い

macOS では `svc #0x80` 命令による直接 syscall はユーザーランドプログラムに推奨されない（Apple は将来的に変更する可能性を明示している）。正規の macOS バイナリ（Go バイナリを含む）は `libSystem.dylib` 経由でシステムコールを発行するため、通常は `svc #0x80` が機械語中に直接現れることはない。

このため、**動的シンボル解析を主体とする**。ただし、シンボル解析でネットワーク関連シンボルが検出されなかった場合でも、機械語中に `svc #0x80` が存在するバイナリは **high risk** として扱う。`svc #0x80` の存在は `libSystem.dylib` を迂回した直接 syscall の発行を意味し、難読化・マルウェア的なバイナリである可能性が高い。

**注記**: `svc #0x80` 検出時には syscall 番号（`x16` レジスタへの即値）の解析は行わない。`svc #0x80` の存在自体を high risk の根拠とする。

#### 1.2.4 macOS と Linux の比較

| 項目 | Linux (ELF) | macOS (Mach-O) |
|------|-------------|----------------|
| バイナリ形式 | ELF | Mach-O / Fat バイナリ |
| パーサーパッケージ | `debug/elf` | `debug/macho` |
| ネットワーク API | `libc.so` / 直接 syscall | `libSystem.dylib` |
| シンボル解析アプローチ | `.dynsym` セクション | インポートシンボルテーブル |
| 静的リンク Go バイナリの検出 | タスク 0070/0072 で対応 | 本タスクのシンボル解析で対応（`libSystem.dylib` へのリンクが常に存在する） |
| 機械語 syscall 解析 | タスク 0070/0072 で対応 | `svc #0x80` 存在時は high risk（syscall 番号解析は行わない） |

### 1.3 目的

Go 標準ライブラリ `debug/macho` を使用して Mach-O バイナリのインポートシンボルを解析し、ネットワーク関連の関数シンボルの有無を検出することで、macOS バイナリに対してもネットワーク操作のリスク判定を行う。

### 1.4 スコープ

- **対象**: macOS（Darwin）上の Mach-O バイナリ（arm64、x86_64）
- **対象**: Fat バイナリ（複数アーキテクチャを含む Mach-O）
- **対象外**: ELF バイナリ（タスク 0069/0070/0072 で対応済み）
- **対象外**: スクリプトファイル（Mach-O でないため）
- **high risk 検出**: シンボル解析でネットワーク関連シンボルが検出されなかった場合でも、機械語中に `svc #0x80` が存在するバイナリは high risk として扱う（syscall 番号の解析は行わない）

## 2. 用語定義

| 用語 | 定義 |
|------|------|
| Mach-O | Mach Object file format。macOS/iOS 等の Apple プラットフォームで使用される実行ファイルフォーマット |
| Fat バイナリ | 複数のアーキテクチャ（arm64、x86_64 等）向けの Mach-O バイナリを1ファイルに格納した形式。ユニバーサルバイナリとも呼ぶ |
| Load Command | Mach-O ファイルのヘッダ後に続くメタデータ構造体。セグメント情報、動的リンク情報等を記述する |
| `libSystem.dylib` | macOS の標準システムライブラリ。POSIX syscall のラッパーを提供する |
| インポートシンボル | バイナリが外部ライブラリから参照する関数シンボル。Mach-O では `__TEXT,__stubs` セクションや dyld 情報に記録される |
| `debug/macho` | Go 標準ライブラリ。Mach-O ファイルの構造解析機能を提供する |
| 直接 syscall | `libSystem.dylib` を経由せず `svc #0x80` 命令で直接カーネルにシステムコールを発行するパターン。macOS の正規バイナリでは発生しない |

## 3. 機能要件

### 3.1 Mach-O バイナリ解析機能

#### FR-3.1.1: Mach-O バイナリの判定

実行ファイルが Mach-O フォーマットであるかどうかをマジックナンバーで判定できること。

Mach-O マジックナンバー：

| マジック | 値 | 意味 |
|----------|-----|------|
| `MH_MAGIC_64` | `0xFEEDFACF` | 64 ビット Mach-O（ネイティブエンディアン） |
| `MH_CIGAM_64` | `0xCFFAEDFE` | 64 ビット Mach-O（バイトスワップ） |
| `FAT_MAGIC` | `0xCAFEBABE` | Fat バイナリ |
| `FAT_CIGAM` | `0xBEBAFECA` | Fat バイナリ（バイトスワップ） |

非 Mach-O ファイル（ELF、スクリプト等）に対してはエラーではなくスキップすること。

#### FR-3.1.2: Fat バイナリのスライス抽出

Fat バイナリを受け取った場合、実行環境のアーキテクチャ（arm64 または x86_64）に対応するスライスを抽出して解析すること。

`debug/macho` パッケージの `FatFile` 型を使用する。

**注記**: 実行環境のアーキテクチャを優先するが、単一スライスのみの場合はそのスライスを解析対象とする。

#### FR-3.1.3: インポートシンボルの解析

Mach-O バイナリから外部ライブラリにインポートされた関数シンボルを取得できること。

`debug/macho` パッケージの `File.ImportedSymbols()` メソッドを使用する。このメソッドは `__TEXT,__stubs` セクションの参照シンボル名を返す。

**注記**: `ImportedSymbols()` が返すシンボル名には、ライブラリプレフィックスが付く場合がある（例: `_socket$UNIX2003`）。シンボル名の正規化（先頭 `_` の除去、バージョンサフィックスの除去）が必要な場合は設計フェーズで確認すること。

#### FR-3.1.4: ネットワーク関連シンボルの判定

以下のシンボルをネットワーク関連として検出すること（タスク 0069 の ELF `.dynsym` 解析と同一の検出対象）：

**POSIX ソケット API:**
- `socket`, `connect`, `bind`, `listen`, `accept`, `accept4`
- `send`, `sendto`, `sendmsg`
- `recv`, `recvfrom`, `recvmsg`
- `getaddrinfo`, `getnameinfo`, `gethostbyname`, `gethostbyname2`
- `inet_ntop`, `inet_pton`, `getpeername`, `getsockname`

**HTTP/TLS ライブラリ:**
- libcurl 系: `curl_easy_init`, `curl_easy_perform`, `curl_multi_perform`
- libssl/OpenSSL 系: `SSL_connect`, `SSL_read`, `SSL_write`, `SSL_new`
- GnuTLS 系: `gnutls_handshake`, `gnutls_record_send`, `gnutls_record_recv`

**注記**: タスク 0069 の `network_symbols.go` で定義済みのシンボルリストを再利用すること。Mach-O と ELF でシンボル名の表記が異なる場合（例: macOS での `_socket`）は設計フェーズで確認し、正規化処理を実装する。

#### FR-3.1.5: `svc #0x80` 直接 syscall の検出と high risk 判定

シンボル解析（FR-3.1.3/3.1.4）でネットワーク関連シンボルが検出されなかった場合、Mach-O バイナリの実行可能セクション（`__TEXT,__text`）を走査し、`svc #0x80` 命令（エンコード `0x00008001`）の有無を確認すること。

`svc #0x80` が1つでも検出された場合、そのバイナリを **high risk** として判定すること。

**判定優先順位**:
1. シンボル解析でネットワーク関連シンボルが検出された → `NetworkDetected`
2. シンボル解析でネットワーク関連シンボルが検出されず、かつ `svc #0x80` が存在する → `AnalysisError`（high risk）
3. シンボル解析でネットワーク関連シンボルが検出されず、かつ `svc #0x80` も存在しない → `NoNetworkSymbols`

**根拠**: 正規の macOS バイナリ（Go バイナリ・C バイナリを問わず）は `libSystem.dylib` 経由でシステムコールを発行するため、機械語中に `svc #0x80` が直接現れることはない。`svc #0x80` の存在は `libSystem.dylib` を意図的に迂回しているパターンであり、難読化・マルウェア的なバイナリである可能性が高い。syscall 番号（`x16` レジスタへの設定値）の解析は行わず、`svc #0x80` の存在自体を high risk の根拠とする。

**実装上の注記**: arm64 の命令は固定長 4 バイトであるため、`svc #0x80` の検出はリトルエンディアンの 4 バイト列 `01 80 00 D4` のバイトパターン検索で実現できる。x86_64 Mach-O の場合は `svc #0x80` に相当するものとして `syscall`（`0F 05`）を検索対象とする（x86_64 macOS での直接 syscall 命令）。

### 3.2 既存インターフェースへの統合

#### FR-3.2.1: ELFAnalyzer インターフェースとの統合

既存の `ELFAnalyzer` インターフェース（[internal/runner/security/elfanalyzer/analyzer.go](../../../internal/runner/security/elfanalyzer/analyzer.go)）は名称が ELF 固有であるため、Mach-O 解析を統合するための共通インターフェースの設計が必要である。

以下の2つのアプローチが考えられる：

1. **新規インターフェース**: `BinaryAnalyzer` 等の汎用インターフェースを新たに定義し、`StandardELFAnalyzer` と新規 `MachOAnalyzer` の両方が実装する
2. **既存インターフェースの拡張**: `ELFAnalyzer` の名称を `BinaryAnalyzer` に変更する（リファクタリング）

具体的な方針は設計フェーズで決定する。

#### FR-3.2.2: IsNetworkOperation フォールバックチェーンへの統合

`IsNetworkOperation` の判定に Mach-O 解析を組み込む。判定の優先順位は以下のとおり（実行プラットフォームに応じて適切な解析器が選択される）：

1. **1st**: `commandProfileDefinitions`（ハードコードリスト）
2. **Linux の場合**:
   - **2nd**: ELF `.dynsym` 解析（タスク 0069）
   - **3rd**: ELF 機械語 syscall 解析結果（タスク 0070/0072、事前解析済みの場合のみ）
3. **macOS の場合**:
   - **2nd**: Mach-O インポートシンボル解析（本タスク）

#### FR-3.2.3: 実行プラットフォームの判定

解析器の選択は実行プラットフォーム（Linux / macOS）に応じて行うこと。`runtime.GOOS` による判定を使用する。

**注記**: runner 自体が Linux 上で動作しつつ、解析対象バイナリが macOS 向けにクロスコンパイルされたものである場合（ファイルが手動でコピーされた等）については、本タスクのスコープ外とする。解析器の選択はバイナリのマジックナンバーによりファイル形式を判定する方式を採用してもよい。具体的な方針は設計フェーズで決定する。

### 3.3 実行時の動作

#### FR-3.3.1: 実行時解析

Mach-O インポートシンボル解析はコマンド実行時に毎回行う。事前キャッシュは行わない。

**理由**: タスク 0069 の ELF `.dynsym` 解析と同様に、インポートシンボルの読み取りは十分に軽量である。

#### FR-3.3.2: 解析失敗時の動作

Mach-O 解析が失敗した場合（ファイル読み取りエラー、不正なフォーマット等）は、ネットワーク操作を含む可能性があるものとして扱い、安全側に倒した判定を行うこと。コマンド実行がブロックされてはならない。

## 4. 非機能要件

### 4.1 パフォーマンス

#### NFR-4.1.1: 解析時間

Mach-O インポートシンボル解析は、一般的なバイナリ（数 MB〜数十 MB）に対して実用的な時間内（1 秒未満）に完了すること。

### 4.2 セキュリティ

#### NFR-4.2.1: 安全なファイル読み取り

Mach-O 解析時のファイル読み取りは、既存の `safefileio` パッケージを使用し、シンボリックリンク攻撃などに対する保護を維持すること。

#### NFR-4.2.2: 不正な Mach-O ファイルへの耐性

不正な Mach-O ファイル（破損、悪意のある細工）に対してクラッシュやパニックを起こさず、安全にエラーを返すこと。Go 標準ライブラリの `debug/macho` パッケージが提供する安全性に依存する。

### 4.3 保守性

#### NFR-4.3.1: 外部依存なし

Go 標準ライブラリ（`debug/macho`）のみを使用し、外部ツールへの依存を持たないこと。

#### NFR-4.3.2: シンボルリストの共通化

ネットワーク関連シンボルのリストは ELF 解析（タスク 0069）と Mach-O 解析（本タスク）で共通のデータ構造を使用すること。シンボル名の正規化が必要な場合は変換レイヤーを設ける。

## 5. 受け入れ条件

### AC-1: Mach-O バイナリの判定

- [ ] Mach-O バイナリ（arm64 / x86_64）に対して解析が実行されること
- [ ] Fat バイナリに対して適切なスライスが選択されて解析されること
- [ ] 非 Mach-O ファイル（ELF、スクリプト等）に対して解析がスキップされ、エラーにならないこと

### AC-2: ネットワークシンボルの検出

- [ ] `socket`, `connect` 等のネットワーク関連シンボルをインポートする Mach-O バイナリが、ネットワーク操作ありと判定されること
- [ ] ネットワーク関連シンボルをインポートしない Mach-O バイナリが、ネットワーク操作なしと判定されること

### AC-3: Go バイナリの検出

- [ ] `net` パッケージを使用する Go バイナリ（`net.Dial` 等）が、ネットワーク操作ありと判定されること
- [ ] ネットワーク操作を行わない Go バイナリが、ネットワーク操作なしと判定されること

### AC-4: フォールバック動作

- [ ] `commandProfileDefinitions` に含まれるコマンドは Mach-O 解析を行わず従来のリストベース判定が適用されること
- [ ] `commandProfileDefinitions` に含まれないコマンドに対して Mach-O 解析が実行されること

### AC-5: 解析失敗時の安全性

- [ ] Mach-O 解析が失敗した場合、コマンド実行がブロックされないこと
- [ ] 不正な Mach-O ファイルに対してパニックが発生しないこと

### AC-7: `svc #0x80` 直接 syscall の high risk 検出

- [ ] シンボル解析でネットワーク関連シンボルが検出されなかった Mach-O バイナリに `svc #0x80` 命令が含まれる場合、high risk と判定されること
- [ ] シンボル解析でネットワーク関連シンボルが検出された場合、`svc #0x80` の有無に関わらず `NetworkDetected` と判定されること（シンボル解析が優先）
- [ ] `svc #0x80` を含まない正規の Mach-O バイナリは high risk と判定されないこと

### AC-6: 既存機能への非影響

- [ ] Linux 環境での ELF 解析（タスク 0069/0070/0072）が引き続き正常に動作すること
- [ ] 既存のテストがすべてパスすること

## 6. テスト方針

### 6.1 ユニットテスト

#### テスト用バイナリの用意

テストフィクスチャとして小さな Mach-O バイナリをリポジトリに含めるか、または Go の `darwin/arm64` 向けクロスコンパイルでテスト時に生成する。

クロスコンパイルでの生成例:
```bash
GOOS=darwin GOARCH=arm64 go build -o testdata/hello_macho ./testdata/hello_macho.go
```

ただし、macOS SDK がない Linux 環境では Mach-O バイナリの生成が困難なため、実際のフィクスチャバイナリをリポジトリに含める方式を優先すること。

#### テストケース一覧

| テストケース | 検証内容 |
|-------------|---------|
| ネットワーク関連シンボルを含む Mach-O（arm64） | ネットワーク操作ありと判定 |
| ネットワーク関連シンボルを含まない Mach-O（arm64） | ネットワーク操作なしと判定 |
| ネットワーク関連シンボルなし + `svc #0x80` あり | high risk と判定 |
| ネットワーク関連シンボルあり + `svc #0x80` あり | NetworkDetected と判定（シンボル解析優先） |
| Fat バイナリ（arm64 + x86_64） | 適切なスライスが選択されて判定 |
| net パッケージを使用する Go バイナリ | ネットワーク操作ありと判定 |
| ネットワーク操作なしの Go バイナリ | ネットワーク操作なしと判定（`svc #0x80` なし） |
| 非 Mach-O ファイル（ELF、スクリプト） | スキップ（エラーなし） |
| 不正な Mach-O ファイル | 安全側判定（パニックしない） |

### 6.2 統合テスト

macOS 環境が利用可能な場合のみ実行する統合テストを提供すること。`runtime.GOOS != "darwin"` の場合はスキップする。

## 7. 設計上の制約と限界

1. **`svc #0x80` 検出は存在確認のみ**: macOS では正規バイナリが `libSystem.dylib` 経由で syscall を発行するため、`svc #0x80` の存在自体を異常とみなして high risk 判定する。syscall 番号（`x16` レジスタへの設定値）の解析は行わない。なお、シンボル解析でネットワーク関連シンボルが検出された場合は `svc #0x80` の有無に関わらず `NetworkDetected` を優先する。

2. **`dlopen` による動的ロード**: 実行時に `dlopen` / `dlsym` で動的にロードされるライブラリ経由のネットワーク操作は検出できない（ELF 解析と同じ制約）。

3. **シンボル名の正規化**: macOS の `ImportedSymbols()` が返すシンボル名には先頭アンダースコア（`_socket`）やバージョンサフィックス（`$UNIX2003`）が付く場合がある。正確な対応は実装フェーズで確認する。

4. **クロスプラットフォーム解析**: runner が Linux 上で動作し、解析対象が macOS バイナリである場合（ファイルをコピーして解析するケース）の対応は本タスクのスコープ外とする。

5. **コード署名（Code Signing）**: macOS バイナリはコード署名が付与されている場合がある。`debug/macho` はコード署名を検証しないが、署名の有無が解析結果に影響しないことを確認すること。

## 8. 先行タスクとの関係

| 項目 | タスク 0069 | タスク 0070 | タスク 0072 | 本タスク（0073）|
|------|------------|------------|------------|----------------|
| 対象 OS | Linux | Linux | Linux | macOS |
| バイナリ形式 | ELF | ELF | ELF | Mach-O |
| 解析手法 | `.dynsym` シンボル解析 | x86_64 機械語 syscall 解析 | arm64 機械語 syscall 解析 | インポートシンボル解析 + `svc #0x80` 存在確認 |
| 対象バイナリ | 動的リンク | 静的リンク（Go 等） | 静的リンク（Go 等） | 動的リンク・Go バイナリ |
| 解析パッケージ | `debug/elf` | `debug/elf` + `x86asm` | `debug/elf` + `arm64asm` | `debug/macho` |
| 実行タイミング | 実行時（毎回） | 事前解析 + 保存 | 事前解析 + 保存 | 実行時（毎回）|
