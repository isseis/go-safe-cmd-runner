# ELF 機械語解析による syscall 静的解析 要件定義書

## 1. 概要

### 1.1 背景

タスク 0069（ELF `.dynsym` 解析）では、動的リンクされたバイナリのネットワーク操作検出を実装する。しかし、静的リンクされたバイナリ（特に Go バイナリ）は `.dynsym` セクションにネットワーク関連シンボルが現れないため、0069 の手法では検出できない。

Go のランタイムは libc を経由せず、`syscall` 命令で直接カーネルにシステムコールを発行する。このため、バイナリの機械語を直接デコードし、`syscall` 命令の直前でシステムコール番号レジスタ（`eax`/`rax`）に設定される即値を解析することで、呼び出されるシステムコールを静的に特定できる。

### 1.2 目的

Go 標準ライブラリ `debug/elf` および準公式パッケージ `golang.org/x/arch/x86/x86asm` を使用して ELF バイナリの機械語を直接デコードし、ネットワーク関連のシステムコール（`socket`, `connect` 等）が含まれるかどうかを事前に検出する。解析結果はファイルのハッシュ値と共に保存し、runner 実行時には保存された解析結果を参照することで実行時コストを最小化する。

### 1.3 スコープ

本タスクは 2 段階のうちの 2nd step であり、1st step（タスク 0069）で検出できない静的リンクされたバイナリを対象とする。

- **対象**: 静的リンクされた ELF バイナリ（Go バイナリ等）
- **対象**: 1st step（タスク 0069）の ELF `.dynsym` 解析でネットワークシンボルが検出されなかったバイナリ
- **対象外**: 非 ELF ファイル（スクリプト等）
- **対象アーキテクチャ**: x86_64 Linux（`syscall` 命令 + `eax`/`rax` レジスタ）

## 2. 用語定義

| 用語 | 定義 |
|------|------|
| syscall 命令 | x86_64 Linux でカーネルにシステムコールを発行する命令（オペコード `0F 05`） |
| syscall 番号 | `eax`/`rax` レジスタに設定されるシステムコール識別番号 |
| 即値設定 | `mov $imm, %eax` のようにレジスタに定数を直接設定するパターン |
| 間接設定 | レジスタ間の `mov`、メモリからのロード、計算結果、関数戻り値などを経由してレジスタに値を設定するパターン |
| 事前解析 | runner 実行前に ELF バイナリの機械語を解析し、結果を記録するフェーズ |
| 解析結果ファイル | 事前解析の結果をファイルのハッシュ値と共に保存したもの |
| x86asm | `golang.org/x/arch/x86/x86asm` パッケージ。x86/x86_64 機械語のデコード機能を提供する Go 準公式ライブラリ |

## 3. 機能要件

### 3.1 事前解析機能

#### FR-3.1.1: ELF バイナリの機械語デコード

対象の実行ファイルを Go 標準ライブラリ `debug/elf` で開き、実行可能セクション（`.text` 等）の機械語を `golang.org/x/arch/x86/x86asm` パッケージでデコードできること。

**使用ライブラリ**:
- `debug/elf`: Go 標準ライブラリ。ELF ファイルの構造解析
- `golang.org/x/arch/x86/x86asm`: Go 準公式パッケージ。x86/x86_64 機械語のデコード

#### FR-3.1.2: syscall 命令の検出

デコードされた命令列から `syscall` 命令（x86_64、オペコード `0F 05`）を検出できること。

#### FR-3.1.3: syscall 番号の即値抽出

`syscall` 命令から逆方向に最大 N 命令（N は設計フェーズで決定、目安: 50）を走査し、`eax`/`rax` レジスタを最初に変更している命令を探す。その命令が即値設定であれば、システムコール番号として抽出できること。

**走査ルール**:
1. `syscall` 命令の位置から逆方向に 1 命令ずつ遡る
2. `eax`/`rax` を変更する命令を発見した時点で走査を終了する
3. N 命令以内に `eax`/`rax` を変更する命令が見つからない場合は「番号不明」とする
4. ジャンプ命令（`jmp`, `je`, `call`, `ret` 等の制御フロー命令）を超えた走査は行わない（ベーシックブロック境界の簡易検出）

対象パターン（x86_64）:
```asm
mov    $0x29, %eax    # 即値設定 → syscall 番号 41 (socket)
syscall
```

```asm
mov    $0x29, %eax    # 即値設定（間に他の命令を挟むケース）
mov    %rsi, %rdi     # eax/rax に無関係な命令
syscall
```

**注記**:
- 走査幅 N の具体的な値は、実際のコンパイラ出力を分析した結果に基づき設計フェーズで決定する。glibc の syscall ラッパーおよび Go ランタイムの個別 syscall ラッパー関数では、1〜3 命令前に即値設定されるパターンが一般的である。
- 将来的にアーキテクチャを拡張する場合、命令パターンはアーキテクチャ別に定義する必要がある（例: aarch64 では `mov xN, #imm` に加え `orr xN, xzr, #imm` も即値設定パターンとなる）。

#### FR-3.1.4: 間接設定の high risk 判定

FR-3.1.3 の逆方向スキャンにおいて、以下のいずれかに該当する場合、その `syscall` 命令は番号不明として **high risk** と判定すること：

1. スキャン範囲内で `eax`/`rax` を変更する命令が見つかったが、即値設定ではない場合
2. スキャン範囲内に `eax`/`rax` を変更する命令が見つからなかった場合
3. スキャン中に制御フロー命令（ベーシックブロック境界）に到達した場合

**注記**: FR-3.1.3/3.1.4 による直接 `syscall` 命令の解析と、FR-3.1.6 による Go ラッパー呼び出しの解析は、**独立した解析パス**として実行される。両パスの結果は集約され、いずれかのパスで番号不明の syscall が検出された場合、全体として high risk と判定される。

#### FR-3.1.5: ネットワーク関連 syscall の判定

以下のシステムコール番号（x86_64 Linux）をネットワーク関連として判定すること：

| syscall | 番号 (x86_64) | 意味 |
|---------|---------------|------|
| `socket` | 41 | ソケット作成 |
| `connect` | 42 | 接続 |
| `accept` | 43 | 接続受け入れ |
| `sendto` | 44 | データ送信 |
| `recvfrom` | 45 | データ受信 |
| `sendmsg` | 46 | メッセージ送信 |
| `recvmsg` | 47 | メッセージ受信 |
| `bind` | 49 | アドレスにバインド |
| `listen` | 50 | 接続待ち受け |
| `socketpair` | 53 | ソケットペア作成 |
| `accept4` | 288 | 接続受け入れ（フラグ付き） |
| `recvmmsg` | 299 | 複数メッセージ受信 |
| `sendmmsg` | 307 | 複数メッセージ送信 |

**注記**: syscall 番号のリストはアーキテクチャ依存であり、データ構造として管理し、将来的に他のアーキテクチャ（aarch64 等）への対応が容易な設計とすること。

#### FR-3.1.6: Go syscall ラッパーの解析

Go 言語で作成されたバイナリは、`syscall` 命令を直接発行するのではなく、`syscall` パッケージ等のラッパー関数を経由する場合が大半である。これに対応するため、以下の解析を行うこと：

1. **ラッパー関数の特定**:
    - **`.gopclntab` セクション** (pclntab: Program Counter Line Table) から関数情報を復元し、標準的な syscall ラッパー関数のアドレス範囲を特定する。
    - 対象関数例: `syscall.Syscall`, `syscall.Syscall6`, `syscall.RawSyscall`, `syscall.RawSyscall6`

2. **`.gopclntab` による関数情報復元**:
    - Go ランタイムはスタックトレース生成とガベージコレクションのために pclntab を必要とするため、`.gopclntab` セクションは strip 後も保持される。
    - pclntab には関数名、開始アドレス、終了アドレスが含まれており、strip されたバイナリでも関数情報を復元できる。
    - pclntab のマジックナンバー（Go バージョンにより異なる）を検出し、適切なパーサーで解析する。

3. **呼び出し元 (Call Site) の特定**:
    - 実行可能セクションを走査し、上記ラッパー関数への `call` 命令（`E8` 等）をすべて特定する。

4. **呼び出し元での引数解析**:
    - 特定された各 `call` 命令の直前を解析し、第1引数（システムコール番号）が即値で渡されているかを確認する。
    - Go の ABI (Application Binary Interface) に従い、Go 1.17 以降のレジスタベース ABI（`RAX` レジスタでの受け渡し）を考慮して解析する。
    - 例: `MOV $0x29, RAX` → `CALL syscall.Syscall` のパターンを検出する。

5. **判定**:
    - 呼び出し元で即値が特定できた場合は、その値をシステムコール番号として採用する。
    - 呼び出し元でも即値が特定できない（変数渡し等）場合は、その呼び出しは番号不明として High Risk と判定する。
    - `.gopclntab` が利用できない場合は、本解析パスはスキップする。

**注記**: 本解析パス（Go ラッパー解析）は FR-3.1.3/3.1.4 の直接 `syscall` 命令解析とは**独立して**実行される。両パスの結果を集約し、最終的な判定を行う。

**pclntab について**:
- Go 1.2 以降、pclntab の構造は複数回変更されている（Go 1.2, 1.16, 1.18, 1.20 で変更あり）。
- 各バージョンはマジックナンバーで識別可能：
  - Go 1.2-1.15: `0xFFFFFFFB`
  - Go 1.16-1.17: `0xFFFFFFFA`
  - Go 1.18-1.19: `0xFFFFFFF0`
  - Go 1.20+: `0xFFFFFFF1`
- 参考: [Golang Internals: Symbol Recovery (Google Cloud Blog)](https://cloud.google.com/blog/topics/threat-intelligence/golang-internals-symbol-recovery)

**メンテナンスコスト**:
- Go のメジャーリリース（約 6 ヶ月ごと）時に pclntab 構造の変更有無を確認する必要がある
- 変更頻度: 大幅な構造変更は 2-3 年に 1 回程度（過去実績: Go 1.16, 1.18, 1.20）
- 対応工数の目安:
  - 変更なし（確認のみ）: 1-2 時間
  - 軽微な変更: 4-6 時間
  - 大幅な構造変更: 1-2 日
- 詳細な対応手順は [pclntab メンテナンスガイド](../../development/pclntab_maintenance.md) を参照

### 3.2 解析結果の保存と利用

#### FR-3.2.1: 解析結果の保存

事前解析の結果を以下の情報と共に保存できること：

- 解析結果スキーマバージョン（`schema_version`）
- 実行ファイルの絶対パス
- ファイルのハッシュ値（SHA256）
- 検出された syscall 番号のリスト
- 間接設定（番号不明）の syscall の有無
- 解析結果のサマリ（ネットワーク操作あり/なし/不明(high risk)）

**スキーマバージョンについて**: 解析結果読み込み時に、保存されたスキーマバージョンとプログラムが期待するスキーマバージョンを比較し、一致しない場合は解析結果を無効とすること。これにより、解析ロジックの修正・改善や検出パターンの追加を行った際に、古い解析結果が使われ続けることを防ぐ。

#### FR-3.2.2: 保存先

解析結果ファイルは既存の `filevalidator` と同じディレクトリに保存すること。ファイル名の生成には既存の `HybridHashFilePathGetter` の仕組みを再利用または拡張すること。

**注記**: ハッシュ検証ファイルと syscall 解析結果ファイルの区別方法（ファイル名のプレフィックス、JSON の `format` フィールド等）は設計フェーズで決定する。

#### FR-3.2.3: runner 実行時の解析結果利用

runner 実行時には以下の手順で解析結果を利用すること：

1. 実行ファイルのハッシュ値を計算する
2. 解析結果ファイルを検索する
3. 解析結果のスキーマバージョンがプログラムの期待するバージョンと一致することを確認する
4. 解析結果のハッシュ値と一致する場合、記録済みの解析結果を利用する
5. 解析結果が存在しない、スキーマバージョンが不一致、またはハッシュ値が一致しない場合は「不明」として扱う

#### FR-3.2.4: 解析結果不在時の動作

解析結果が存在しない場合、runner 実行時に `objdump` による解析は行わない。解析結果は「不明」として扱い、既存の判定ロジックにフォールバックすること。

**理由**: `objdump` の実行はコストが高く、実行時に毎回行うのは非現実的である。

### 3.3 事前解析コマンド

#### FR-3.3.1: record コマンドとの統合

事前解析は既存の `record` コマンド（ハッシュ記録コマンド）と統合するか、または別のサブコマンドとして提供すること。具体的な統合方法は設計フェーズで決定する。

### 3.4 IsNetworkOperation への統合

#### FR-3.4.1: フォールバックチェーンにおける位置づけ

`IsNetworkOperation` の判定は以下の優先順位で行うこと：

1. **1st**: `commandProfileDefinitions`（ハードコードリスト）
2. **2nd**: ELF `.dynsym` 解析（タスク 0069、実行時に毎回）
3. **3rd**: ELF 機械語 syscall 解析結果（本タスク、事前解析済みの場合のみ）

#### FR-3.4.2: high risk 判定の伝播

syscall 番号不明（間接設定）の場合の high risk 判定は、`IsNetworkOperation` の呼び出し元に伝播すること。呼び出し元はこの情報を利用してリスクレベルを適切に設定できること。

## 4. 非機能要件

### 4.1 パフォーマンス

#### NFR-4.1.1: 実行時の解析結果参照

runner 実行時の解析結果参照はハッシュ計算とファイル読み込みのみであり、実行時コストを最小限に抑えること。

#### NFR-4.1.2: 事前解析のパフォーマンス

Goライブラリによる事前解析は大きなバイナリに対して相応の時間を要することを許容する。ただし、解析の進捗状況をユーザーに表示すること。

**パフォーマンス目標値**:

| バイナリサイズ | 目標時間 |
|---------------|---------|
| 小規模 (< 1MB) | < 1秒 |
| 中規模 (1-10MB) | < 5秒 |
| 大規模 (> 10MB) | < 30秒 |

### 4.2 セキュリティ

#### NFR-4.2.1: 解析結果の改竄検知

解析結果ファイルに記録されたハッシュ値と実行ファイルの実際のハッシュ値を比較することで、実行ファイルの改竄を検知すること。解析結果のハッシュ値が一致しない場合は解析結果を無効とすること。

#### NFR-4.2.2: 解析結果ファイルの安全な読み書き

解析結果ファイルの読み書きは既存の `safefileio` パッケージを使用し、シンボリックリンク攻撃などに対する保護を維持すること。

### 4.3 保守性

#### NFR-4.3.1: 外部ツールへの依存排除

機械語デコードは Go ライブラリ（`debug/elf`, `golang.org/x/arch/x86/x86asm`）のみを使用し、`objdump` 等の外部コマンドへの依存を持たないこと。これにより、事前解析フェーズおよび runner 実行時の両方で外部ツールへの依存がない。

#### NFR-4.3.2: アーキテクチャ拡張性

syscall 番号テーブルとアセンブリ命令パターンの定義を分離し、将来的に x86_64 以外のアーキテクチャ（aarch64 等）を追加する際の拡張が容易な構造とすること。

### 4.4 テスト可能性

#### NFR-4.4.1: 機械語デコーダーの抽象化

機械語デコード処理をインターフェースで抽象化し、テスト時にモック可能であること。また、テスト用のバイト列を直接渡してユニットテストを実行可能であること。

## 5. 受け入れ条件

### AC-1: syscall 命令の検出

- [x] ELF バイナリの実行可能セクションから `syscall` 命令を正しく検出できること
- [x] `syscall` 命令から逆方向にスキャンし、`eax`/`rax` への即値設定を抽出できること
- [x] 即値設定命令と `syscall` 命令の間に `eax`/`rax` に無関係な命令が挟まっていても正しく抽出できること

### AC-2: ネットワーク関連 syscall の判定

- [x] `socket`(41), `connect`(42) 等のネットワーク関連 syscall 番号が検出された場合、ネットワーク操作ありと判定されること
- [x] ネットワーク関連以外の syscall 番号のみが検出された場合、ネットワーク操作なしと判定されること

### AC-3: 間接設定の high risk 判定

- [x] スキャン範囲内で `eax`/`rax` を変更する命令が即値設定でない場合（レジスタ間 `mov`、メモリロード等）、high risk と判定されること
- [x] スキャン範囲内に `eax`/`rax` を変更する命令が見つからない場合、high risk と判定されること
- [x] スキャン中に制御フロー命令に到達した場合、high risk と判定されること
- [x] high risk の判定理由が「syscall 番号が静的に決定不可能」であることが記録されること

### AC-4: 解析結果の保存と読み込み

- [x] 事前解析結果がスキーマバージョンおよびハッシュ値と共に解析結果ファイルに保存されること
- [x] 解析結果ファイルが既存の filevalidator と同じディレクトリに保存されること
- [x] runner 実行時に解析結果ファイルが正しく読み込まれること

### AC-5: 解析結果の整合性検証

- [x] 実行ファイルのハッシュ値と解析結果のハッシュ値が一致する場合、保存された解析結果が利用されること
- [x] 実行ファイルが変更された（ハッシュ不一致の）場合、解析結果が無効化されること
- [x] 解析結果のスキーマバージョンがプログラムの期待するバージョンと異なる場合、解析結果が無効化されること

### AC-6: 解析結果不在時の安全な動作

- [x] 解析結果が存在しない場合、runner がエラーにならず正常に動作すること
- [x] 解析結果不在時は解析結果が「不明」として扱われ、既存のロジックにフォールバックすること

### AC-7: 非 ELF ファイルのエラーハンドリング

- [x] 非 ELF ファイル（スクリプト、他フォーマットのバイナリ等）に対して事前解析を実行した場合、適切なエラーまたはスキップが行われること
- [x] 対象外アーキテクチャ（非 x86_64）の ELF ファイルに対して、適切なエラーまたはスキップが行われること

### AC-8: フォールバックチェーンの統合

- [x] `commandProfileDefinitions` に含まれるコマンドは従来通りリストベースの判定が適用されること
- [x] リストにないコマンドに対して、ELF `.dynsym` 解析（0069）→ syscall 解析結果（本タスク）の順でフォールバックが動作すること

### AC-9: 既存機能への非影響

- [x] 既存の `IsNetworkOperation` の判定結果が、`commandProfileDefinitions` に含まれるコマンドに対して変更されないこと
- [x] 既存のテストがすべてパスすること

### AC-10: Go syscall ラッパーの解決

- [x] `syscall.Syscall` 等の標準ラッパー関数を使用している単純な Go プログラム（net パッケージ使用等）において、High Risk（不明）とならずに正しくネットワーク操作の有無を判定できること
- [x] ラッパー関数の呼び出し元でシステムコール番号が即値指定されているケースを検出できること

### AC-11: filevalidator の統合解析結果ストア対応

- [x] 新しい FileAnalysisRecord 形式でハッシュ保存・検証が正常に動作すること
- [x] syscall 解析結果と共存するレコード形式で保存できること

**注記**: HashManifest 形式（旧形式）から FileAnalysisRecord 形式（新形式）への
自動移行ロジックは実装しない。ユーザーは `record` コマンドを再実行することで
新形式のレコードを作成する。

## 6. テスト方針

### 6.1 ユニットテスト

#### 機械語デコーダーのテスト

テスト用のバイト列（機械語）を直接デコーダーに渡し、syscall 検出ロジックの正確性をテストする。

- `mov (%rsp), %eax` + `syscall` のバイト列 → メモリロード、High Risk と判定
- `syscall` のみ（スキャン範囲内に `eax`/`rax` 変更命令なし） → High Risk と判定
- `jmp` + `mov $0x29, %eax` + `syscall` のバイト列 → 制御フロー境界を超えた即値設定は無視、High Risk と判定
- `mov $0x2a, %eax` + `syscall` のバイト列 → connect(42) を検出
- `mov %ebx, %eax` + `syscall` のバイト列 → 間接設定、high risk と判定
- `mov $0x01, %eax` + `syscall` のバイト列 → write(1)、非ネットワーク
- `syscall` なし → syscall 呼び出しなし

#### 解析結果の保存・読み込みテスト

テストケース:
- 解析結果の保存と読み込みの往復テスト
- ハッシュ一致時の解析結果利用
- ハッシュ不一致時の解析結果無効化
- スキーマバージョン不一致時の解析結果無効化
- 不正な JSON 解析結果ファイルの処理

### 6.2 統合テスト

テスト環境に `gcc` が存在する場合のみ実行：

1. 小さな C プログラム（`socket()` を呼ぶもの）をコンパイル
2. 事前解析を実行
3. 解析結果ファイルが生成されることを検証
4. runner 実行時に解析結果が利用されることを検証

テスト環境に `gcc` が存在しない場合はテストをスキップすること。

**注記**: 本実装は外部ツール（`objdump` 等）に依存しないため、`gcc` さえあれば統合テストを実行可能である。

## 7. 設計上の制約と限界

1. **アーキテクチャ依存**: syscall 番号は x86_64 固有である。aarch64 では syscall 番号が異なり、`svc #0` 命令を使用する。初期実装は x86_64 のみを対象とする。aarch64 対応時は `golang.org/x/arch/arm64/arm64asm` パッケージを使用する。
2. **間接的なレジスタ設定**: `mov $imm, %eax` 以外のパターン（レジスタ間 `mov`、メモリからのロード、計算結果等）では syscall 番号を静的に決定できない。これは high risk として扱う。特に Go ランタイムの汎用 `Syscall6` ラッパーはスタックから syscall 番号をロードするため、常に high risk と判定される。ただし、Go の標準的なラッパー関数に関しては FR-3.1.6 により呼び出し元解析を行い、可能な限り解決を試みる。
3. **逆方向スキャンの限界**: 線形デコードではベーシックブロック境界を厳密に検出できないため、制御フロー命令の簡易検出で代替する。コンパイラの最適化により即値設定命令と `syscall` 命令の間に他の命令が挿入されるケースは、スキャン幅 N で対応するが、N を超える距離の場合は high risk と判定される。
4. **0F 05 バイトパターン検索の誤検出**: `findSyscallInstructions()` は単純なバイト列検索（`bytes.Index`）で `0F 05` パターンを探すため、命令オペランド内に偶然 `0F 05` が現れた場合（例：`mov $0x050F0000, %eax` → バイト列 `b8 00 00 0f 05`）に誤検出する可能性がある。これは命令デコード失敗後のリカバリ時にも発生する。詳細仕様書 §8.5 で設計上の考慮事項として言及されている。実用的には `.text` セクションはほぼ全てが有効な命令で構成されるため誤検出は稀であり、発生しても High Risk 判定により安全側に倒れる設計となっている。
5. **大規模バイナリ**: 大きなバイナリのデコードは時間を要する。事前解析 + 解析結果保存方式により、この影響は事前解析時に限定される。
6. **Stripされた Go バイナリ**: Go バイナリは strip されても `.gopclntab` セクション（pclntab）が保持される。Go ランタイムがスタックトレースとガベージコレクションにこのテーブルを使用するためである。pclntab から関数名とアドレスを復元することで、strip されたバイナリでも Go ラッパー解析（FR-3.1.6）が可能である。ただし、以下の制限がある：
   - pclntab の構造は Go バージョンにより異なるため、サポートするバージョン範囲を限定する（Go 1.18 以降を対象）
   - 難読化ツール（garble 等）を使用したバイナリでは関数名が変更されるため、解析できない可能性がある
   - pclntab 自体が意図的に破壊された場合は解析不可となり、High Risk と判定される

### 7.1 1st step との関係

| 項目 | 1st step (タスク 0069) | 2nd step (本タスク) |
|------|------------------------|---------------------|
| 手法 | ELF `.dynsym` 解析 | ELF 機械語デコード + syscall 番号解析 |
| 対象 | 動的リンクされたバイナリ | 静的リンクされたバイナリ |
| 外部依存 | なし（Go 標準ライブラリ） | なし（Go 標準 + 準公式ライブラリ） |
| 実行タイミング | コマンド実行時に毎回 | 事前解析 + 解析結果保存 |
| 保存先 | なし（毎回解析） | 既存の filevalidator と同じディレクトリ |
| フォールバック順位 | 2nd（ハードコードリストの次） | 3rd（ELF 解析の次） |

## 8. 検討したが採用しなかった案

### 8.1 objdump コマンド + 正規表現によるパース

#### 概要

`objdump -d` コマンドで逆アセンブルを行い、その出力を正規表現でパースして syscall 命令と syscall 番号を検出する方式。

#### 検討理由

objdump は広く普及しており、逆アセンブル結果を人間が読める形式で出力するため、実装が比較的容易と考えられた。

#### 不採用理由

1. **出力フォーマットの揺らぎ**: GNU objdump と llvm-objdump、またはバージョン間で出力フォーマット（空白の数、タブ、AT&T 構文の微妙な違い）が異なる可能性がある。これに対応する正規表現は複雑になり、リグレッションテストのコストが増加する。

2. **外部ツールへの依存**: objdump のインストールが必要となり、最小構成の Docker イメージや一部の環境では追加インストールが必要になる。

3. **テストの複雑性**: objdump の出力をモックするか、実際の objdump を呼ぶ統合テストが必要になる。

4. **プロセス起動コスト**: 大きなバイナリの逆アセンブルでプロセス起動・パイプ通信のオーバーヘッドが発生する。

#### objdump 出力の揺らぎ例

```
# GNU objdump (タブ区切り)
  401000:       b8 29 00 00 00          mov    $0x29,%eax

# llvm-objdump (スペース区切り、若干異なる)
  401000: b8 29 00 00 00               movl   $0x29, %eax
```

### 8.2 採用した方式（ELF 解析ライブラリ）との比較

| 項目 | objdump + 正規表現 | ELF 解析ライブラリ（採用） |
|------|-------------------|---------------------------|
| 出力フォーマットの安定性 | 環境依存で揺らぐ | 自前デコードで安定 |
| 外部ツール依存 | objdump 必須 | なし |
| テスト容易性 | モック複雑 | バイト列を直接テスト可能 |
| 実装コスト | 低（テキスト処理のみ） | 中（ELF 構造の理解必要） |
| パフォーマンス | プロセス起動オーバーヘッド | オーバーヘッドなし |
| 長期保守性 | 出力揺らぎへの継続対応必要 | 安定 |

## 9. 実装後タスク

### 9.1 開発者ドキュメントの更新

実装完了後、以下の内容を `docs/development/` 配下の開発者向けドキュメントに追加・更新すること：

1. **x86_64 命令デコードの制限事項**
   - 可変長命令（1〜15バイト）に起因するデコード失敗時の動作
   - 1バイトスキップによる再同期アプローチとその限界
   - 誤検出・見落としの可能性とリスク許容の根拠

2. **設計判断の記録**
   - デコード失敗時に High Risk としない理由
   - Pass 1（直接 syscall 命令）と Pass 2（Go ラッパー呼び出し）の分離設計
   - 安全側への設計原則（FR-3.1.4）との整合性
