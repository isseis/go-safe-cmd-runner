# ELF 動的シンボル解析によるネットワーク操作検出 要件定義書

## 1. 概要

### 1.1 背景

現在の `IsNetworkOperation` 関数は、`commandProfileDefinitions` にハードコーディングされたコマンド名リスト（`curl`, `wget`, `ssh`, `git` 等）に基づいてネットワーク操作の有無を判定している。この方式では以下の問題がある：

1. **未知のコマンドに対応できない**: リストに含まれないコマンド（カスタムビルドされたバイナリ、新しいツール等）のネットワーク操作を検出できない
2. **メンテナンスコスト**: 新しいネットワークコマンドが登場するたびにリストを手動で更新する必要がある
3. **精度の限界**: コマンド名だけでは、実際にネットワーク操作を行うかどうかを正確に判断できない

### 1.2 目的

ELF バイナリの動的シンボルテーブル（`.dynsym`）を解析し、ネットワーク関連の関数シンボルの有無を検出することで、`commandProfileDefinitions` に含まれないコマンドに対してもネットワーク操作のリスク判定を行う。

### 1.3 スコープ

本タスクは 2 段階のうちの 1st step であり、動的リンクされたバイナリを対象とする。

- **対象**: 動的リンクされた ELF バイナリ（C/C++ 等で作成され、libc を動的リンクしているもの）
- **対象外**: 静的リンクされたバイナリ（Go バイナリ等）は 2nd step（タスク 0070）で対応する
- **対象外**: スクリプト言語（Python, Shell 等）はインタプリタが実行するため、スクリプト自体の ELF 解析は対象外

## 2. 用語定義

| 用語 | 定義 |
|------|------|
| ELF | Executable and Linkable Format。Linux で使用される実行ファイルフォーマット |
| `.dynsym` | 動的シンボルテーブル。動的リンク時に参照されるシンボル情報を格納する ELF セクション |
| 動的リンク | 実行時に共有ライブラリ（.so）をリンクする方式 |
| 静的リンク | コンパイル時にすべてのライブラリをバイナリに組み込む方式 |
| ネットワークシンボル | ネットワーク操作に関連する関数シンボル（socket, connect 等） |

## 3. 機能要件

### 3.1 ELF 解析機能

#### FR-3.1.1: ELF バイナリの判定

実行ファイルが ELF フォーマットであるかどうかを判定できること。ELF でないファイル（スクリプト、他フォーマットのバイナリ等）に対してはエラーではなく、解析をスキップすること。

#### FR-3.1.2: 動的シンボルテーブルの解析

ELF バイナリの `.dynsym` セクションからインポートされた関数シンボルを取得し、ネットワーク関連のシンボルが含まれるかどうかを検出できること。

#### FR-3.1.3: 検出対象シンボル

以下のカテゴリのシンボルを検出対象とすること：

**socket 系（POSIX ソケット API）:**
- `socket`, `connect`, `bind`, `listen`, `accept`, `accept4`
- `send`, `sendto`, `sendmsg`
- `recv`, `recvfrom`, `recvmsg`
- `getaddrinfo`, `getnameinfo`, `gethostbyname`, `gethostbyname2`
- `inet_ntop`, `inet_pton`, `getpeername`, `getsockname`

**HTTP/TLS ライブラリ:**
- libcurl 系: `curl_easy_init`, `curl_easy_perform`, `curl_multi_perform`
- libssl/OpenSSL 系: `SSL_connect`, `SSL_read`, `SSL_write`, `SSL_new`
- GnuTLS 系: `gnutls_handshake`, `gnutls_record_send`, `gnutls_record_recv`

**注記**:
- 検出対象シンボルのリストは設定やデータ構造として管理し、将来の追加・変更が容易な設計とすること。
- シンボル名のバージョニングサフィックス（例: `connect@GLIBC_2.2.5`）について: Go 標準ライブラリの `debug/elf` パッケージの `DynamicSymbols()` はバージョンサフィックスを除去した状態でシンボル名を返すため、完全一致検索で問題ない。実装時にバージョンサフィックスのストリッピング処理は不要である。

### 3.2 IsNetworkOperation への統合

#### FR-3.2.1: フォールバックとしての適用

ELF 解析は、既存の `commandProfileDefinitions` によるハードコードリストに**含まれないコマンド**に対してのみ適用すること。ハードコードリストに存在するコマンドは、従来通りリストベースの判定を優先する。

#### FR-3.2.2: 判定結果の利用

ELF 解析でネットワーク関連シンボルが検出された場合、そのコマンドはネットワーク操作を行う可能性があると判定すること。

### 3.3 実行時の動作

#### FR-3.3.1: 実行時解析

ELF `.dynsym` 解析はコマンド実行時に毎回行う。事前キャッシュは行わない。

**理由**: `.dynsym` セクションの読み取りは ELF ヘッダとセクションヘッダの解析のみで完了するため、十分に軽量である。

#### FR-3.3.2: 解析失敗時の動作

ELF 解析が失敗した場合（ファイル読み取りエラー、不正な ELF フォーマット等）は、ネットワーク操作を含む可能性があるものとして扱い、middle risk として判定すること。ただし、ログメッセージには「ネットワーク操作が含まれる」とは出力せず、「ELF 解析失敗のためネットワーク操作の有無を判定できず、安全側に倒してリスクありと判定」と記録すること。解析失敗によってコマンド実行がブロックされてはならない。

## 4. 非機能要件

### 4.1 パフォーマンス

#### NFR-4.1.1: 解析時間

ELF `.dynsym` 解析は、一般的なバイナリ（数 MB〜数十 MB）に対して実用的な時間内に完了すること。

### 4.2 セキュリティ

#### NFR-4.2.1: 安全なファイル読み取り

ELF 解析時のファイル読み取りは、既存の `safefileio` パッケージを使用し、シンボリックリンク攻撃などに対する保護を維持すること。

#### NFR-4.2.2: 不正な ELF ファイルへの耐性

不正な ELF ファイル（破損、悪意のある細工）に対してクラッシュやパニックを起こさず、安全にエラーを返すこと。Go 標準ライブラリの `debug/elf` パッケージが提供する安全性に依存する。

### 4.3 保守性

#### NFR-4.3.1: 外部依存なし

Go 標準ライブラリ（`debug/elf`）のみを使用し、外部ツールへの依存を持たないこと。

### 4.4 テスト可能性

#### NFR-4.4.1: インターフェースによる抽象化

ELF 解析ロジックはインターフェースを介してアクセスし、テスト時にモック可能であること。

## 5. 受け入れ条件

### AC-1: ELF バイナリの判定

- [ ] ELF バイナリに対して解析が実行されること
- [ ] 非 ELF ファイル（シェルスクリプト、テキストファイル等）に対して解析がスキップされ、エラーにならないこと

### AC-2: ネットワークシンボルの検出

- [ ] ネットワーク関連シンボル（socket, connect 等）を含む動的リンクされたバイナリが、ネットワーク操作ありと判定されること
- [ ] ネットワーク関連シンボルを含まない動的リンクされたバイナリが、ネットワーク操作なしと判定されること

### AC-3: HTTP/TLS ライブラリの検出

- [ ] libcurl をリンクするバイナリが、ネットワーク操作ありと判定されること
- [ ] libssl/OpenSSL をリンクするバイナリが、ネットワーク操作ありと判定されること

### AC-4: フォールバック動作

- [ ] `commandProfileDefinitions` に含まれるコマンド（例: curl）は、ELF 解析を行わず従来のリストベース判定が適用されること
- [ ] `commandProfileDefinitions` に含まれないコマンドに対して ELF 解析が実行されること

### AC-5: 静的リンクバイナリの扱い

- [ ] 静的リンクされたバイナリ（`.dynsym` がないもの）に対して、解析が「検出なし」を返し、エラーにならないこと

### AC-6: 解析失敗時の安全性

- [ ] ELF 解析が失敗した場合、コマンド実行がブロックされないこと
- [ ] ELF 解析が失敗した場合、ネットワーク操作を含む可能性ありとして middle risk と判定されること
- [ ] ELF 解析失敗時のログに、判定理由（解析失敗による安全側判定）が記録されること
- [ ] 不正な ELF ファイルに対してパニックが発生しないこと

### AC-7: 既存機能への非影響

- [ ] 既存の `IsNetworkOperation` の判定結果が、`commandProfileDefinitions` に含まれるコマンドに対して変更されないこと
- [ ] 既存のテストがすべてパスすること

## 6. テスト方針

### ユニットテスト

ELF 解析のテストにはテスト用のバイナリファイルを使用する。以下の方法でテストバイナリを用意する：

1. **テスト用 C プログラムのコンパイル**: テスト実行時に `gcc` で小さなテスト用バイナリを生成する（`go:generate` または `TestMain` で）
2. **テスト用 ELF ファイルの事前生成**: テストフィクスチャとして小さな ELF バイナリをリポジトリに含める

テスト環境に `gcc` が存在しない場合はテストをスキップすること。

### テストケース一覧

| テストケース | 検証内容 |
|-------------|---------|
| ネットワーク関連シンボルを含むバイナリ | ネットワーク操作ありと判定 |
| ネットワーク関連シンボルを含まないバイナリ | ネットワーク操作なしと判定 |
| 静的リンクされたバイナリ | 検出なし（エラーではない） |
| 非 ELF ファイル（スクリプト等） | スキップ（エラーではない） |
| 不正な ELF ファイル | ネットワーク操作を含む可能性ありとして middle risk 判定（パニックしない） |
| commandProfileDefinitions に含まれるコマンド | ELF 解析は実行されない |

## 7. 設計上の制約と限界

### 7.1 既知の限界

1. **静的リンクバイナリ**: `.dynsym` に依存するため、静的リンクされたバイナリ（特に Go バイナリ）のネットワーク操作は検出できない。これは 2nd step（タスク 0070: objdump による syscall 番号解析）で対応する。
2. **`dlopen` による動的ロード**: 実行時に `dlopen` / `dlsym` で動的にロードされるライブラリ経由のネットワーク操作は検出できない。
3. **False positive**: ネットワーク関連シンボルが `.dynsym` に存在しても、実行時に必ずしもネットワーク操作が行われるとは限らない。しかし、これはセキュリティツールとして安全側に倒す（false positive は許容、false negative は最小化）という方針に合致する。

### 7.2 2nd step との関係

| 項目 | 1st step (本タスク) | 2nd step (タスク 0070) |
|------|---------------------|------------------------|
| 手法 | ELF `.dynsym` 解析 | objdump 逆アセンブル + syscall 番号解析 |
| 対象 | 動的リンクされたバイナリ | 静的リンクされたバイナリ |
| 外部依存 | なし（Go 標準ライブラリ） | objdump（事前解析時のみ） |
| 実行タイミング | コマンド実行時に毎回 | 事前解析 + キャッシュ |
| 保存先 | なし（毎回解析） | 既存の filevalidator と同じディレクトリ |
