# Go Safe Command Runner - 設計・実装概要

## 概要

Go Safe Command Runnerは、特権タスクの委譲と自動バッチ処理のために設計されたセキュリティ重視のコマンド実行フレームワークです。本システムは、厳格なセキュリティ境界を維持しながら特権操作の安全な実行を可能にする複数のセキュリティ制御層を提供します。

**主要なユースケース:**
- root権限を必要とする定期バックアップ操作
- 非rootユーザーへの特定管理タスクの委譲
- セキュリティ制御を伴う自動システムメンテナンス
- ファイル整合性検証を伴うバッチ処理

## システムアーキテクチャ

### 高レベルアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                コマンドラインインターフェース                │
├─────────────────────┬───────────────────┬───────────────────┤
│ runner              │ record            │ verify            │
│ (メイン実行器)      │ (ハッシュ記録)    │ (ファイル検証)    │
└─────────────────────┴───────────────────┴───────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                       コアエンジン                          │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ 設定管理        │  │ セキュリティ    │                  │
│  │                 │  │ フレームワーク  │                  │
│  └─────────────────┘  └─────────────────┘                  │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ コマンド実行    │  │ ファイル整合性  │                  │
│  │                 │  │ 検証            │                  │
│  └─────────────────┘  └─────────────────┘                  │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ 環境管理        │  │ 特権管理        │                  │
│  │                 │  │                 │                  │
│  └─────────────────┘  └─────────────────┘                  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                 システムインターフェース層                  │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │ 安全なファイル  │  │ プロセス実行    │                  │
│  │ I/O             │  │                 │                  │
│  │ (シンボリック   │  │                 │                  │
│  │ リンク保護)     │  │                 │                  │
│  └─────────────────┘  └─────────────────┘                  │
└─────────────────────────────────────────────────────────────┘
```

### コアコンポーネント

#### 1. 設定管理 (`internal/runner/config/`)
- **目的**: TOMLベースの設定読み込みと検証
- **主要機能**:
  - 必須フィールドチェックを伴うスキーマ検証
  - パスセキュリティ検証（絶対パス、相対コンポーネントなし）
  - デフォルト値の割り当て
  - セクション間のクロスリファレンス検証

**実装のハイライト:**
```go
// 検証を伴う安全な設定読み込み
func (l *Loader) LoadConfig(path string) (*runnertypes.Config, error) {
    data, err := safefileio.SafeReadFile(path)  // 安全なファイル読み込み
    if err := toml.Unmarshal(data, &cfg); err != nil {
        return nil, fmt.Errorf("failed to parse config: %w", err)
    }
    // パス検証とデフォルト割り当て
}
```

#### 2. コマンド実行エンジン (`internal/runner/executor/`)
- **目的**: 出力キャプチャとタイムアウト制御を伴う安全なコマンド実行
- **主要機能**:
  - プロセス分離とリソース管理
  - グローバルレベルとコマンドレベルでの設定可能なタイムアウト
  - サイズ制限を伴う構造化出力キャプチャ
  - シグナルハンドリングを伴うバックグラウンドプロセスサポート

#### 3. ファイル整合性システム (`internal/filevalidator/`)
- **目的**: 改ざんされたバイナリの実行を防ぐためのSHA-256ベースファイル検証
- **主要機能**:
  - ハッシュ記録と検証ワークフロー
  - 制御された昇格を伴う特権ファイルアクセス
  - 競合状態を防ぐアトミック操作
  - 特権管理との統合

**セキュリティフロー:**
```
ファイルアクセス要求 → 権限チェック → 特権昇格（必要時）
→ ファイルオープン → 特権復元 → ハッシュ計算 → 検証
```

#### 4. 特権管理 (`internal/runner/privilege/`)
- **目的**: 包括的な監査証跡を伴う制御された特権昇格
- **主要機能**:
  - グローバルミューテックスを使用したスレッドセーフな特権操作
  - パニック保護を伴う自動特権復元
  - ネイティブrootとsetuidバイナリ実行の両方をサポート
  - セキュリティ失敗時の緊急シャットダウンプロトコル

**特権昇格パターン:**
```go
func (m *Manager) WithPrivileges(ctx ElevationContext, fn func() error) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    if err := m.escalatePrivileges(ctx); err != nil {
        return err
    }

    defer m.emergencyShutdownOnRestoreFailure(fn) // フェイルセーフメカニズム
    return fn()
}
```

#### 5. 環境セキュリティ (`internal/runner/environment/`)
- **目的**: ゼロトラスト環境変数フィルタリング
- **主要機能**:
  - グローバルレベルとグループレベルでの許可リストベースフィルタリング
  - 危険パターン検出（パスワード、トークンなど）
  - 継承制御（継承/明示的/拒否モード）
  - 変数名と値の検証

#### 6. 安全なファイル操作 (`internal/safefileio/`)
- **目的**: 現代的なLinuxセキュリティプリミティブを使用したシンボリックリンクセーフなファイル操作
- **主要機能**:
  - シンボリックリンク攻撃防止のためのopenat2とRESOLVE_NO_SYMLINKS
  - ステップバイステップパス検証
  - アトミックファイル操作
  - フォールバックメカニズムを伴うクロスプラットフォーム互換性

#### 7. セキュリティフレームワーク (`internal/runner/security/`)
- **目的**: 一元化されたセキュリティ検証とポリシー執行
- **主要機能**:
  - コマンドパス許可リスト検証
  - 危険コマンド検出
  - ファイル権限検証
  - パストラバーサル攻撃防止

## データフローアーキテクチャ

### コマンド実行フロー

```
設定読み込み → セキュリティ検証 → グループ処理 → コマンド実行

1. 設定読み込み:
   ├── TOML解析と検証
   ├── パスセキュリティチェック
   ├── デフォルト値割り当て
   └── クロスリファレンス検証

2. セキュリティ検証:
   ├── ファイル整合性検証
   ├── 環境変数フィルタリング
   ├── コマンドパス検証
   └── 権限チェック

3. グループ処理:
   ├── 依存関係解決
   ├── 優先順位決定
   ├── リソース割り当て（一時ディレクトリ）
   └── 環境準備

4. コマンド実行:
   ├── 特権昇格（必要時）
   ├── 分離を伴うプロセス生成
   ├── 出力キャプチャと監視
   ├── 特権復元
   └── クリーンアップとログ記録
```

### ファイル検証フロー

```
ファイルパス入力 → セキュリティチェック → ハッシュ計算 → 検証 → 結果

1. セキュリティチェック:
   ├── パス検証（シンボリックリンクなし、絶対パス）
   ├── 権限分析
   └── 特権要件判定

2. ファイルアクセスとハッシュ計算:
   ├── 特権昇格（ファイルがrootアクセスを要求する場合）
   ├── 安全なファイルオープン
   ├── 特権復元（ファイルオープン直後）
   ├── ストリーミングSHA-256計算（通常権限で実行）
   └── ハッシュ比較準備

3. 検証:
   ├── 保存されている値とのハッシュ比較
   ├── 詳細なコンテキストを伴うエラー報告
   └── 監査ログ記録
```

## セキュリティ設計原則

### 1. 多層防御
単一障害点がシステム全体を危険にさらさないよう複数のセキュリティ層を実装:
- **入力検証**: エントリポイントでのすべての入力検証
- **パスセキュリティ**: 包括的なパス検証とシンボリックリンク保護
- **ファイル整合性**: すべての重要ファイルのハッシュベース検証
- **特権制御**: 制御された昇格による最小特権原則
- **環境分離**: 厳格な許可リストベース環境フィルタリング
- **コマンド検証**: 許可リストベースコマンド実行制御

### 2. ゼロトラストモデル
システム環境への暗黙的な信頼なし:
- 使用前のすべてのファイル検証
- 許可リストによる環境変数フィルタリング
- 既知の良好なパターンに対するコマンド検証
- 必要時のみの特権付与と即座の取り消し

### 3. フェイルセーフ設計
安全に失敗するようシステムを設計:
- すべての操作に対するデフォルト拒否
- セキュリティ失敗時の緊急シャットダウン
- 包括的なエラーハンドリングとログ記録
- セキュリティ機能が利用できない場合の優雅な劣化

### 4. 監査と監視
セキュリティ関連操作への完全な可視性:
- セキュリティコンテキストを伴う構造化ログ
- 特権操作メトリクスと追跡
- セキュリティイベント記録
- 重要エラーのマルチチャンネル報告

## 実装パターン

### 1. インターフェース駆動設計
テスト性とモジュール性のためのインターフェースの多用:
```go
type PrivilegeManager interface {
    WithPrivileges(context ElevationContext, fn func() error) error
    IsSupported() bool
}

type FileValidator interface {
    Verify(filepath string) error
    Record(filepath string) (string, error)
}
```

### 2. 継承よりコンポジション
機能拡張のためのコンポーネントコンポジション:
```go
type ValidatorWithPrivileges struct {
    *Validator                    // 基本機能
    privMgr      PrivilegeManager // 拡張機能
    logger       *slog.Logger     // 可観測性
}
```

### 3. コンテキスト対応操作
セキュリティと可観測性のためのコンテキストを持つ操作:
```go
type ElevationContext struct {
    Operation  string
    FilePath   string
    Reason     string
}
```

### 4. 設定のためのビルダーパターン
合理的なデフォルトを持つ柔軟な設定:
```go
func NewRunnerWithOptions(config *Config, opts ...Option) (*Runner, error) {
    options := &runnerOptions{}
    for _, opt := range opts {
        opt(options)
    }
    // オプション適用とランナー作成
}
```

## テスト戦略

### 1. 単体テスト
- すべてのコアコンポーネントの包括的テストカバレッジ
- 外部依存関係のモック実装
- カスタムエラータイプによるエラー条件テスト
- 並行操作の競合状態テスト

### 2. 統合テスト
- エンドツーエンドワークフローテスト
- ファイルシステム相互作用テスト
- 特権操作テスト
- 設定読み込みと検証テスト

### 3. セキュリティテスト
- シンボリックリンク攻撃防止テスト
- パストラバーサル攻撃テスト
- 特権昇格境界テスト
- 環境変数インジェクションテスト

### 4. パフォーマンステスト
- ハッシュ計算パフォーマンスベンチマーク
- メモリ使用量最適化
- 並行操作パフォーマンス
- 大ファイル処理効率

## デプロイメント考慮事項

### 1. バイナリ配布
- 特権昇格のためのsetuidビット設定
- root所有権要件
- デプロイメント前のバイナリ整合性検証
- 安全なインストール手順

### 2. 設定管理
- 安全なハッシュディレクトリ権限（755以上の制限）
- 書き込み保護された設定ファイル
- 重要ファイルの定期整合性検証
- 設定テンプレート管理

### 3. 監視とアラート
- セキュリティイベントの構造化ログ
- 一元化ログのためのsyslog統合
- 緊急シャットダウンイベント監視
- パフォーマンスメトリクス収集

### 4. セキュリティ操作
- 設定の定期セキュリティ監査
- 特権操作監視
- ファイル整合性検証スケジュール
- インシデント対応手順

## パフォーマンス特性

### 1. ハッシュ計算
- 効率的なストリーミングハッシュ計算
- リソース枯渇を防ぐファイルサイズ制限
- 複数ファイルの並列処理
- メモリ効率的な実装

### 2. 環境処理
- マップ構造を使用したO(1)許可リスト検索
- パターンマッチングのためのコンパイル済み正規表現
- 最小限の文字列操作
- バッチ処理最適化

### 3. 特権操作
- グローバルミューテックスによる特権操作の直列化
- システムコールを使用した高速特権昇格/復元
- パフォーマンス監視のためのメトリクス収集
- リソース使用量追跡

## 将来の拡張性

### 1. プラグインアーキテクチャ
インターフェース駆動設計により簡単な拡張が可能:
- カスタムハッシュアルゴリズム
- 追加の特権バックエンド
- 拡張セキュリティバリデータ
- カスタム出力フォーマッタ

### 2. プラットフォームサポート
Linux/Unixへの現在の焦点と以下への拡張性:
- Windows特権管理
- macOSセキュリティ機能
- コンテナランタイム統合
- クラウドプラットフォームアダプタ

### 3. 統合ポイント
以下との統合のための明確に定義されたインターフェース:
- 設定管理システム
- 監視とアラートプラットフォーム
- 監査とコンプライアンスシステム
- アイデンティティとアクセス管理

## まとめ

Go Safe Command Runnerは、多層セキュリティアプローチ、包括的な入力検証、安全な特権管理、広範な監査機能を通じて、セキュリティエンジニアリングのベストプラクティスを実証しています。システムは安全に失敗し、セキュリティ関連操作への完全な可視性を提供するよう設計されており、セキュリティを重視する環境での本番使用に適しています。

実装は、インターフェース駆動設計、コンポジションベースアーキテクチャ、包括的テスト戦略を含む現代的なGo開発パターンを示しています。システムのモジュラー設計により、厳格なセキュリティ境界を維持しながら簡単な拡張とカスタマイズが可能です。
