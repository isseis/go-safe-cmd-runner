# x86_64 命令デコードの技術詳細

本ドキュメントは、ELF 機械語解析による syscall 静的解析機能における
x86_64 命令デコードの技術的な動作仕様と設計判断を記録する。

## 1. デコード失敗時の動作

### 1.1 1バイトスキップによる再試行

命令デコードに失敗した場合、1バイトスキップして次の位置からデコードを再試行する。

```
失敗位置: pos
次の試行位置: pos + 1
```

これは x86_64 の可変長命令（1〜15バイト）に起因する制約である。
可変長命令では「次の正しい命令境界」を確実に見つける方法がないため、
1バイトずつ進めて次のデコード可能な位置を探す設計としている。

### 1.2 再同期メカニズム

`.text` セクションは通常ほぼ全てが有効な命令で構成されているため、
デコード失敗後も数バイト以内で正常な命令境界に再同期する。

```
例: 命令境界がずれた場合
実際の命令列: [5バイト命令][3バイト命令][2バイト命令]
ずれた開始:      ^ここから開始
              → 1-3バイト程度のデコード失敗後、正常な命令境界に到達
```

実用上、再同期は x86_64 コードにおいて通常 1〜3 バイト以内で完了する。
最悪ケース（15バイトの不正デコード）は稀であり、
後続の命令がデコードされれば正確性に影響しない。

### 1.3 誤検出リスク

デコード失敗後の再同期過程で命令境界がずれた場合、
偶然 `0F 05` パターンがデータ領域内に現れると、
誤って syscall 命令として検出する可能性がある。

ただし、この場合も逆方向スキャンで syscall 番号の解析を試みるため、
不正な syscall 命令の場合は以下のいずれかとなる：

- 妥当な syscall 番号が見つからない → `unknown:*` として High Risk 判定
- 偶然妥当な番号に見える → 誤検出（理論上のリスクだが、実用上は極めて稀）

## 2. 設計判断の根拠

### 2.1 デコード失敗を High Risk としない理由

1. **Pass 1 の解析対象は直接 syscall 命令**であり、デコード失敗は
   syscall 命令自体の検出には影響しにくい。syscall 命令は `0F 05` の
   2バイト固定であり、デコード失敗がこの 2バイトパターンの検出精度に
   直接影響することは少ない。

2. **デコード失敗が多発するケースは稀**であり、過度に High Risk 判定を
   行うと実用性が低下する。`.text` セクションは通常有効な命令で構成されて
   おり、デコード失敗はデータ領域の混入やアライメント不一致など
   特殊なケースに限られる。

3. **Pass 2（Go ラッパー解析）でのデコード失敗**も、必ずしも
   syscall ラッパー呼び出しの見落としを意味しない。CALL 命令は
   正常にデコードされることが多く、周辺のデコード失敗が
   CALL ターゲットの解決に影響する可能性は低い。

### 2.2 安全側への設計原則との整合性

本設計では「検出できない syscall 番号」を High Risk とする（FR-3.1.4）。

- **デコード失敗**: 「命令自体を認識できない」ケース
- **syscall 番号不明**: 「syscall 命令は認識できたが番号を特定できない」ケース

この 2つは異なる性質の問題であり、区別して扱う：

- syscall 命令が正常にデコードされた場合に番号が不明 → **High Risk**
- デコード自体の失敗 → **ログ出力のみ**（リスク分類に影響しない）

### 2.3 デコード失敗の可視化

デコード失敗は `DecodeStatistics` 構造体で統計情報を収集し、
以下のログ出力で可視化する：

- **個別ログ**: `findSyscallInstructions()` 内で `slog.Debug` により出力。
  出力件数は `maxDecodeFailureLogs`（= 10）で制限。
- **サマリログ**: record コマンドで `slog.Debug` によりファイルパス、
  デコード失敗総数、解析バイト数を出力。

これにより、デコード失敗が多発するバイナリの調査が可能となり、
必要に応じて解析ロジックの改善や対象バイナリの手動検証を行える。
