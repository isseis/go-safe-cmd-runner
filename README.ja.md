# Go Safe Command Runner

特権タスクの委譲と自動バッチ処理のために設計された、包括的なセキュリティ制御を備えたGoによる安全なコマンド実行フレームワークです。

プロジェクトページ: https://github.com/isseis/go-safe-cmd-runner/

## 背景

Go Safe Command Runnerは、以下のような環境における安全なコマンド実行の重要なニーズに対応します：
- 一般ユーザーが特権操作を安全に実行する必要がある場合
- 自動システムがセキュアなバッチ処理機能を必要とする場合
- コマンド実行前にファイルの整合性検証が不可欠な場合
- 環境変数の公開に厳格な制御が必要な場合
- コマンド実行に監査証跡とセキュリティ境界が必要な場合

一般的な用途には、定期バックアップ、システム保守タスク、セキュリティ制御を維持しながら特定の管理操作を非rootユーザーに委譲することなどが含まれます。

## ⚠️ 破壊的変更（セキュリティ強化）

**最新バージョンでは重要なセキュリティ改善と破壊的変更が導入されています：**

### 削除された機能（セキュリティ）
- **`--hash-directory`フラグ**: カスタムハッシュディレクトリ攻撃を防ぐためrunnerから完全削除
- **カスタムハッシュディレクトリAPI**: 内部APIはプロダクションビルドでカスタムハッシュディレクトリを受け付けない
- **ハッシュディレクトリ設定**: 設定ファイルでのハッシュディレクトリ指定はサポートされない
- **PATH環境変数継承**: 環境変数PATHは親プロセスから継承されない

### セキュリティ強化
- **事前実行検証**: 設定ファイルと環境ファイルの使用前検証により、悪意のある設定攻撃を防止（詳細は[ファイル整合性検証](#ファイル整合性検証)参照）
- **固定ハッシュディレクトリ**: プロダクションビルドはデフォルトハッシュディレクトリ（`/usr/local/etc/go-safe-cmd-runner/hashes`）のみ使用
- **セキュア固定PATH**: セキュア固定PATH（`/sbin:/usr/sbin:/bin:/usr/bin`）を使用し、PATH操作攻撃を排除（詳細は[環境分離](#環境分離)参照）
- **API分離**: テスト用と本番用APIがビルドタグで完全に分離
- **静的解析**: コードとビルドでのセキュリティ違反の自動検出
- **検証強化**: 一元管理によるより強力なファイル整合性検証
- **攻撃ベクター排除**: カスタムハッシュディレクトリとPATH操作攻撃ベクターの完全防止

### 移行ガイド
- **設定**: TOML設定ファイルから`hash_directory`設定を削除
- **スクリプト**: スクリプトや自動化から`--hash-directory`フラグを削除
- **開発**: `//go:build test`タグを使用してテスト用の分離されたAPIを使用
- **PATH依存関係**: 必要な全バイナリが標準システムパス（/sbin、/usr/sbin、/bin、/usr/bin）にあることを確認

詳細な移行情報については、[検証API文書](docs/verification_api.md)を参照してください。

## 機能

### コアセキュリティ機能
- **事前実行検証**: 設定ファイルと環境ファイルの使用前検証（詳細は[セキュリティ強化](#セキュリティ強化)参照）
- **ハッシュディレクトリセキュリティ**: 固定デフォルトハッシュディレクトリによる攻撃防止（詳細は[セキュリティ強化](#セキュリティ強化)参照）
- **セキュア固定PATH**: PATH操作攻撃の排除（詳細は[セキュリティ強化](#セキュリティ強化)参照）
- **ファイル整合性検証**: 実行前の実行ファイルと設定ファイルのSHA-256ハッシュ検証
- **リスクベースコマンド制御**: 高リスク操作を自動的にブロックし、安全なコマンドの実行を許可するインテリジェントなセキュリティ評価
- **ユーザー・グループ実行セキュリティ**: 包括的な検証と監査証跡を備えた安全なユーザー・グループ切り替え
- **環境変数分離**: グローバルレベルとグループレベルでの許可リストベースの環境変数フィルタリング
- **権限管理**: 制御された権限昇格と自動権限降下
- **パス検証**: シンボリックリンク攻撃防止を備えたコマンドパス解決
- **設定検証**: 包括的なTOML設定ファイル検証
- **機密データ保護**: 全出力におけるパスワード、トークン、APIキーの自動検出と編集

### コマンド実行
- **バッチ処理**: 依存関係管理を備えた組織化されたグループでのコマンド実行
- **バックグラウンド実行**: 適切なシグナル処理を備えた長時間実行プロセスのサポート
- **出力キャプチャ**: 機密データの自動編集機能を備えた構造化ログ記録と出力管理
- **拡張ドライランモード**: 包括的なセキュリティ分析とリスク評価を伴う現実的なシミュレーション
- **タイムアウト制御**: コマンド実行の設定可能なタイムアウト
- **ユーザー・グループコンテキスト**: 適切な検証を伴う特定ユーザーまたはグループでのコマンド実行
- **リスク評価**: 設定可能な閾値を伴うコマンドセキュリティリスクレベルの自動評価

### ログとモニタリング
- **マルチハンドラーログ**: 複数の出力先への同時ログ配信（コンソール、ファイル、Slack）
- **Slack統合**: セキュリティイベントと障害のリアルタイム通知
- **監査ログ**: 特権操作とセキュリティイベントの包括的な監査証跡
- **機密データ削除**: ログからの機密情報の自動検出と削除
- **構造化ログ**: 豊富なコンテキスト情報を含むJSON形式のログ
- **ULID実行追跡**: 時系列順に並べ可能な汎用一意識別子による実行追跡

### ファイル操作
- **セーフファイルI/O**: セキュリティチェック付きのシンボリックリンク対応ファイル操作
- **ハッシュ記録**: 後の検証のための重要ファイルのSHA-256ハッシュ記録
- **検証ツール**: ファイル整合性検証のためのスタンドアロンユーティリティ

## アーキテクチャ

システムは関心の明確な分離を伴うモジュラーアーキテクチャに従います：

```
cmd/                    # コマンドライン エントリーポイント
├── runner/            # メインコマンドランナーアプリケーション
├── record/            # ハッシュ記録ユーティリティ
└── verify/            # ファイル検証ユーティリティ

internal/              # コア実装
├── cmdcommon/         # 共有コマンドユーティリティ
├── color/             # ターミナルカラーサポートと制御
├── common/            # 共通ユーティリティとファイルシステム抽象化
├── filevalidator/     # ファイル整合性検証
│   └── encoding/      # ハッシュストレージ用ファイル名エンコーディング
├── groupmembership/   # ユーザー・グループメンバーシップ検証
├── logging/           # インタラクティブUIとSlack統合を備えた高度なログシステム
├── redaction/         # 機密データの自動フィルタリング
├── runner/            # コマンド実行エンジン
│   ├── audit/         # セキュリティ監査ログ
│   ├── bootstrap/     # システム初期化とブートストラップ
│   ├── cli/           # コマンドラインインターフェース管理
│   ├── config/        # 設定管理
│   ├── environment/   # 環境変数処理とフィルタリング
│   ├── errors/        # 一元化エラー処理
│   ├── executor/      # コマンド実行ロジック
│   ├── hashdir/       # ハッシュディレクトリセキュリティ管理
│   ├── privilege/     # 権限管理
│   ├── resource/      # 統一リソース管理（通常・ドライラン）
│   ├── risk/          # リスクベースコマンド評価
│   ├── runnertypes/   # 型定義とインターフェース
│   └── security/      # セキュリティ検証フレームワーク
├── safefileio/        # セキュアファイル操作
├── terminal/          # ターミナル機能検出とインタラクティブUIサポート
└── verification/      # 一元化ファイル検証管理（事前実行検証、パス解決）
```

## コマンドラインツール

### メインランナー
```bash
# 設定ファイルからコマンドを実行
./runner -config config.toml

# ドライランモード（実行なしでプレビュー）
./runner -config config.toml -dry-run

# 設定ファイルの検証
./runner -config config.toml -validate

# カスタムログディレクトリとレベル
./runner -config config.toml -log-dir /var/log/go-safe-cmd-runner -log-level debug

# Slack通知付きで実行（環境変数GSCR_SLACK_WEBHOOK_URLが必要）
GSCR_SLACK_WEBHOOK_URL=https://hooks.slack.com/services/... ./runner -config config.toml

# リスク評価のみモード（実行せずに解析）
./runner -config config.toml -dry-run -validate
```

### ハッシュ管理
```bash
# ファイルハッシュの記録（デフォルトハッシュディレクトリ使用: /usr/local/etc/go-safe-cmd-runner/hashes）
./record -file /path/to/executable

# 既存ハッシュの強制上書き
./record -file /path/to/file -force

# ファイル整合性の検証（デフォルトハッシュディレクトリ使用: /usr/local/etc/go-safe-cmd-runner/hashes）
./verify -file /path/to/file

# 注記: -hash-dirオプションはテストや特別な場合に引き続き利用可能
./record -file /path/to/file -hash-dir /custom/test/hashes
```

## 設定

### 基本設定例
```toml
version = "1.0"

[global]
timeout = 3600
workdir = "/tmp"
log_level = "info"
# パフォーマンス向上のため標準システムパスの検証をスキップ
skip_standard_paths = true
# セキュリティのための環境変数許可リスト
env_allowlist = [
    "PATH",
    "HOME",
    "USER",
    "LANG"
]
# 実行前に検証するファイル
verify_files = ["/etc/passwd", "/bin/bash"]

[[groups]]
name = "backup"
description = "システムバックアップ操作"
priority = 1
# グループ固有の環境変数（グローバル設定を上書き）
env_allowlist = ["PATH", "HOME", "BACKUP_DIR"]

[[groups.commands]]
name = "database_backup"
description = "データベースのバックアップ"
cmd = "mysqldump"
args = ["--all-databases", "--single-transaction"]
env = ["BACKUP_DIR=/backups"]
# セキュリティのため特定ユーザーで実行
run_as_user = "mysql"
run_as_group = "mysql"
# データベース操作には中リスクコマンドを許可
max_risk_level = "medium"

[[groups.commands]]
name = "system_backup"
description = "システムファイルのバックアップ"
cmd = "rsync"
args = ["-av", "/etc/", "/backups/etc/"]
# 高リスク操作には明示的な承認が必要
max_risk_level = "high"
```

### 高度な設定機能
```toml
[global]
# パフォーマンス向上のため標準システムパスの検証をスキップ
skip_standard_paths = true
# グローバルファイル検証リスト
verify_files = ["/usr/bin/rsync", "/etc/rsync.conf"]

[[groups]]
name = "web_deployment"
description = "Webアプリケーションのデプロイメント"
priority = 2
# 厳格な環境制御（空リスト = 環境変数なし）
env_allowlist = []
# グループ固有のファイル検証
verify_files = ["/usr/local/bin/deploy.sh"]

[[groups.commands]]
name = "deploy_app"
cmd = "/usr/local/bin/deploy.sh"
args = ["production"]
# デプロイユーザーと特定グループで実行
run_as_user = "deployer"
run_as_group = "www-data"
# 低リスクデプロイコマンドのみ許可
max_risk_level = "low"
# 空のenv_allowlistのため環境変数は利用不可

[[groups.commands]]
name = "package_update"
cmd = "/usr/bin/apt"
args = ["update"]
# パッケージ管理操作は中リスク
max_risk_level = "medium"
# 必要時に昇格された権限で実行
run_as_user = "root"
```

### 環境変数セキュリティ
システムは環境変数に対して厳格な許可リストベースのアプローチを実装します：

1. **グローバル許可リスト**: すべてのグループで利用可能な基本環境変数を定義
2. **グループ上書き**: グループは独自の許可リストを定義し、グローバル設定を完全に上書き可能
3. **継承**: 明示的な許可リストのないグループはグローバル設定を継承
4. **ゼロトラスト**: 未定義の許可リストは環境変数が渡されないことを意味

### リスクベースコマンド制御
システムはセキュリティリスクレベルに基づいてコマンド実行を自動評価・制御します：

1. **リスクレベル評価**: コマンドは自動的に低、中、高、クリティカルリスクに分類
2. **設定可能な閾値**: 各コマンドは`max_risk_level`を使用して許可する最大リスクレベルを指定可能
3. **自動ブロック**: リスク閾値を超えるコマンドは自動的にブロック
4. **リスクカテゴリ**:
   - **低リスク**: 基本ファイル操作（ls、cat、grep）
   - **中リスク**: ファイル変更（cp、mv、chmod）、パッケージ管理（apt、yum）
   - **高リスク**: システム管理（mount、systemctl）、破壊的操作（rm -rf）
   - **クリティカルリスク**: 特権昇格コマンド（sudo、su）- 常にブロック

### ユーザーとグループ実行
特定のユーザーとグループへのコマンド実行の安全な委譲：

1. **ユーザーコンテキスト**: `run_as_user`を使用して特定ユーザーでコマンド実行
2. **グループコンテキスト**: `run_as_group`を使用して特定グループコンテキストを設定
3. **メンバーシップ検証**: システムは実行前にユーザーとグループのメンバーシップを検証
4. **監査証跡**: すべてのユーザー・グループコンテキスト切り替えの完全な監査ログ

### 環境変数設定
機密設定は環境変数として設定します：

```bash
# Slack通知用のwebhook URL
export GSCR_SLACK_WEBHOOK_URL=https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK

# オプション: デフォルトログ設定の上書き
export LOG_LEVEL=info
export LOG_DIR=/var/log/go-safe-cmd-runner

# 実行例
./runner -config config.toml
```

**セキュリティ注意**: 機密な環境変数は適切に管理してください：
- 環境変数は子プロセスに継承されるため、適切にフィルタリングされます
- シェルの履歴に機密情報が残らないよう注意してください
- プロダクション環境では適切なシークレット管理システムを使用してください

## セキュリティモデル

### ファイル整合性検証
- **事前実行検証**: 設定ファイルと環境ファイルの使用前ハッシュ検証により、悪意のある設定攻撃を防止
- **ハッシュディレクトリセキュリティ**: 固定デフォルトハッシュディレクトリによりカスタムハッシュディレクトリ攻撃を防止（詳細は[セキュリティ強化](#セキュリティ強化)参照）
- すべての実行ファイルと重要ファイルは事前記録されたSHA-256ハッシュと照合して検証
- 設定ファイルと環境ファイルは実行前に自動的に検証
- グループ固有およびグローバルファイル検証リスト
- 特権アクセスへの自動フォールバックを伴う一元化検証管理
- 検証が失敗した場合は実行を中止

### リスクベースセキュリティ制御
- **インテリジェントリスク評価**: コマンドはセキュリティリスクに対して自動評価
- **設定可能リスク閾値**: 各コマンドは許容可能なリスクレベルを定義可能
- **自動脅威ブロック**: 高リスクおよび特権昇格コマンドをブロック
- **リスクベース監査ログ**: コマンドリスクレベルに基づく拡張ログ

### ユーザーとグループセキュリティ
- **セキュアユーザー切り替え**: 適切な検証を伴う特定ユーザーでのコマンド実行
- **グループメンバーシップ検証**: システムは実行前にグループメンバーシップを確認
- **特権境界強制**: ユーザー・グループ特権昇格の厳格な制御
- **完全監査証跡**: すべてのユーザー・グループコンテキスト変更の完全なログ

### 権限管理
- 初期化後の自動権限降下
- 特定コマンドの制御された権限昇格
- 最小権限原則の強制
- リスク対応権限管理
- セキュリティコンテキスト付き包括的監査ログ

### 環境分離
- **セキュア固定PATH**: 環境変数PATH継承を完全に排除し、セキュア固定PATH（/sbin:/usr/sbin:/bin:/usr/bin）を使用してPATH操作攻撃を排除
- 厳格な許可リストベースの環境変数フィルタリング
- 環境変数インジェクション攻撃からの保護
- グループレベルおよびグローバル環境制御
- セキュアな変数参照解決
- 環境変数での機密データの自動検出

### ログセキュリティ
- **機密データ編集**: シークレット、トークン、APIキー、機密パターンの自動検出と編集
- **マルチチャンネルセキュア通知**: データ保護を伴う暗号化Slack webhook通信
- **監査証跡保護**: 構造化形式とリスクコンテキストによる改ざん耐性ログ
- **アクセス制御**: ログファイルの権限とセキュアストレージ実践
- **リアルタイムセキュリティアラート**: セキュリティ違反と高リスク操作の即座の通知

## スコープ外

このプロジェクトは明示的に以下を提供**しません**：
- **コンテナオーケストレーション**やDocker統合
- **ネットワークセキュリティ**機能（ファイアウォール、VPNなど）
- **ユーザー認証**や認可システム
- **WebインターフェースやREST API**
- **データベース管理**機能
- **リアルタイム監視**やアラートシステム
- **クロスプラットフォームGUI**アプリケーション
- **パッケージ管理**やソフトウェアインストール

Unix系環境でのファイル整合性検証を伴うセキュアなコマンド実行に焦点を当てています。

## ライセンス
本プロジェクトはMITライセンスで公開されています。詳細は[LICENSE](./LICENSE)ファイルをご参照ください。

## ビルドとインストール

### 前提条件
- Go 1.23以降（slicesパッケージサポート、range over count に必要）
- golangci-lint（開発用）
- gofumpt（コードフォーマット用）

### ビルドコマンド
```bash
# すべてのバイナリをビルド
make build

# 特定のバイナリをビルド
make build/runner
make build/record
make build/verify

# テストを実行
make test

# リンターを実行
make lint

# コードをフォーマット（変更されたファイルのみ）
make fmt

# すべてのGoファイルをフォーマット
make fmt-all

# ビルド成果物をクリーン
make clean

# ベンチマークを実行
make benchmark

# カバレッジレポートを生成
make coverage
```

### インストール
```bash
# ソースからインストール
git clone https://github.com/isseis/go-safe-cmd-runner.git
cd go-safe-cmd-runner
make build

# システムロケーションにバイナリをインストール
sudo install -o root -g root -m 4755 build/runner /usr/local/bin/go-safe-cmd-runner
sudo install -o root -g root -m 0755 build/record /usr/local/bin/go-safe-cmd-record
sudo install -o root -g root -m 0755 build/verify /usr/local/bin/go-safe-cmd-verify
```

## 開発

### 依存関係
- `github.com/pelletier/go-toml/v2` - TOML設定パーシング
- `github.com/oklog/ulid/v2` - 実行追跡と識別のためのULID生成
- `github.com/stretchr/testify` - テストフレームワーク
- `golang.org/x/term` - インタラクティブ機能のためのターミナル機能検出

### テスト
```bash
# すべてのテストを実行
go test -v ./...

# 特定パッケージのテストを実行
go test -v ./internal/runner

# 統合テストを実行
make integration-test

# Slack通知テストを実行（GSCR_SLACK_WEBHOOK_URLが必要）
make slack-notify-test
make slack-group-notification-test
```

### プロジェクト構造
コードベースはGoのベストプラクティスに従います：
- テスト容易性のためのインターフェース駆動設計
- カスタムエラー型による包括的エラー処理
- 広範囲な検証を伴うセキュリティファーストアプローチ
- 明確な境界を持つモジュラーアーキテクチャ

### ULIDによる実行識別
システムは実行追跡にULID（汎用一意字句順ソート可能識別子）を使用：
- **時系列順ソート可能**: ULIDは作成時刻順に自然に並べられる
- **URL安全**: 特殊文字なし、ファイル名やURLに適している
- **コンパクト**: 26文字固定長（UUIDの36文字より短い）
- **衝突耐性**: 単調エントロピーにより同一ミリ秒内でも一意性を保証
- **例**: `01K2YK812JA735M4TWZ6BK0JH9`

## 貢献

このプロジェクトはセキュリティと信頼性を重視しています。貢献する際は：
- セキュリティファーストの設計原則に従う
- 新機能には包括的なテストを追加
- 設定変更に対してはドキュメントを更新
- すべてのセキュリティ検証が適切にテストされていることを確認

質問や貢献については、プロジェクトのイシュートラッカーを参照するか、メンテナにお問い合わせください。
